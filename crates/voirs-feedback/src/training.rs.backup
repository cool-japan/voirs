//! Interactive training system implementation
//!
//! This module provides structured training exercises, guided learning paths,
//! and adaptive difficulty progression for speech synthesis improvement.

use crate::traits::{
    ExerciseCategory, ExerciseHistory, ExerciseSpecification, ExerciseType, FeedbackResponse,
    FeedbackResult, FocusArea, ProgressIndicators, SuccessCriteria, TrainingExercise,
    TrainingProvider, TrainingResult, TrainingScores, UserBehaviorPatterns, UserFeedback,
};
use crate::FeedbackError;
use async_trait::async_trait;
use chrono::{DateTime, Utc};
use std::collections::HashMap;
use std::sync::{Arc, RwLock};
use std::time::{Duration, Instant};
use uuid::Uuid;
use voirs_evaluation::prelude::{PronunciationEvaluatorImpl, QualityEvaluator};
use voirs_evaluation::traits::{PronunciationEvaluator, QualityEvaluator as QualityEvaluatorTrait};
use voirs_sdk::AudioBuffer;

/// Interactive training system
#[derive(Clone)]
pub struct InteractiveTrainer {
    /// Exercise library
    exercise_library: Arc<RwLock<ExerciseLibrary>>,
    /// Quality evaluator for assessment
    quality_evaluator: Arc<QualityEvaluator>,
    /// Pronunciation evaluator for assessment
    pronunciation_evaluator: Arc<PronunciationEvaluatorImpl>,
    /// Training sessions
    active_sessions: Arc<RwLock<HashMap<String, TrainingSession>>>,
    /// Configuration
    config: TrainingConfig,
    /// System metrics
    metrics: Arc<RwLock<TrainingMetrics>>,
    /// Collaborative learning system
    collaborative_learning: Arc<CollaborativeLearningSystem>,
}

impl InteractiveTrainer {
    /// Create a new interactive trainer
    pub async fn new() -> Result<Self, FeedbackError> {
        Self::with_config(TrainingConfig::default()).await
    }

    /// Create with custom configuration
    pub async fn with_config(config: TrainingConfig) -> Result<Self, FeedbackError> {
        let quality_evaluator =
            Arc::new(
                QualityEvaluator::new()
                    .await
                    .map_err(|e| FeedbackError::TrainingError {
                        message: format!("Failed to initialize quality evaluator: {e}"),
                        source: Some(Box::new(e)),
                    })?,
            );

        let pronunciation_evaluator =
            Arc::new(PronunciationEvaluatorImpl::new().await.map_err(|e| {
                FeedbackError::TrainingError {
                    message: format!("Failed to initialize pronunciation evaluator: {e}"),
                    source: Some(Box::new(e)),
                }
            })?);

        let exercise_library = Arc::new(RwLock::new(Self::create_default_exercises()));
        let collaborative_learning = Arc::new(CollaborativeLearningSystem::new().await?);

        Ok(Self {
            exercise_library,
            quality_evaluator,
            pronunciation_evaluator,
            active_sessions: Arc::new(RwLock::new(HashMap::new())),
            config,
            metrics: Arc::new(RwLock::new(TrainingMetrics::default())),
            collaborative_learning,
        })
    }

    /// Start a new training session
    pub async fn start_session(
        &self,
        user_id: &str,
        session_config: Option<TrainingSessionConfig>,
    ) -> Result<TrainingSession, FeedbackError> {
        let config = session_config.unwrap_or_default();
        let session_id = Uuid::new_v4().to_string();

        let session = TrainingSession {
            session_id: session_id.clone(),
            user_id: user_id.to_string(),
            config,
            current_exercise: None,
            completed_exercises: Vec::new(),
            statistics: SessionStatistics::default(),
            start_time: Utc::now(),
            status: TrainingSessionStatus::Active,
        };

        // Store session
        {
            let mut sessions = self.active_sessions.write().unwrap();
            sessions.insert(session_id.clone(), session.clone());
        }

        // Update metrics
        {
            let mut metrics = self.metrics.write().unwrap();
            metrics.total_sessions += 1;
            metrics.active_sessions += 1;
        }

        Ok(session)
    }

    /// Get exercises for user based on skill level and preferences with spaced repetition
    pub async fn get_recommended_exercises(
        &self,
        user_id: &str,
        skill_level: f32,
        focus_areas: &[FocusArea],
    ) -> Result<Vec<TrainingExercise>, FeedbackError> {
        // Extract exercises from library before async operations
        let exercises = {
            let library = self.exercise_library.read().unwrap();
            library.exercises.clone()
        };

        let mut recommended = Vec::new();

        // Get user's exercise history for spaced repetition
        let exercise_history = self.get_user_exercise_history(user_id).await?;

        // Filter exercises by skill level and focus areas
        for exercise in &exercises {
            // Check skill level compatibility
            let skill_match = (exercise.difficulty - skill_level).abs() <= 0.3;

            // Check focus area overlap
            let focus_match = exercise
                .focus_areas
                .iter()
                .any(|area| focus_areas.contains(area));

            if skill_match && focus_match {
                recommended.push(exercise.clone());
            }
        }

        // Apply spaced repetition algorithm
        let spaced_exercises = self.apply_spaced_repetition(&recommended, &exercise_history);

        // Sort by spaced repetition priority and relevance
        let mut final_recommendations = spaced_exercises;
        final_recommendations.sort_by(|a, b| {
            let a_priority = self.calculate_spaced_repetition_priority(a, &exercise_history);
            let b_priority = self.calculate_spaced_repetition_priority(b, &exercise_history);
            b_priority
                .partial_cmp(&a_priority)
                .unwrap_or(std::cmp::Ordering::Equal)
        });

        // Limit to reasonable number
        final_recommendations.truncate(self.config.max_recommended_exercises);

        Ok(final_recommendations)
    }

    /// Get user's exercise history for spaced repetition calculations
    async fn get_user_exercise_history(
        &self,
        user_id: &str,
    ) -> Result<HashMap<String, ExerciseHistory>, FeedbackError> {
        // In a real implementation, this would query a database
        // For now, return an empty history
        Ok(HashMap::new())
    }

    /// Apply spaced repetition algorithm to exercise selection
    fn apply_spaced_repetition(
        &self,
        exercises: &[TrainingExercise],
        history: &HashMap<String, ExerciseHistory>,
    ) -> Vec<TrainingExercise> {
        let mut spaced_exercises = Vec::new();
        let now = Utc::now();

        for exercise in exercises {
            if let Some(exercise_hist) = history.get(&exercise.exercise_id) {
                // Calculate if exercise is due for review based on spaced repetition
                let time_since_last = now
                    .signed_duration_since(exercise_hist.last_attempted)
                    .to_std()
                    .unwrap_or_default();

                let due_interval = self.calculate_spaced_repetition_interval(
                    exercise_hist.repetition_number,
                    exercise_hist.ease_factor,
                    exercise_hist.last_performance,
                );

                // Include exercise if it's due for review or new
                if time_since_last >= due_interval || exercise_hist.repetition_number == 0 {
                    spaced_exercises.push(exercise.clone());
                }
            } else {
                // New exercise - always include
                spaced_exercises.push(exercise.clone());
            }
        }

        spaced_exercises
    }

    /// Calculate spaced repetition interval based on SM-2 algorithm
    fn calculate_spaced_repetition_interval(
        &self,
        repetition_number: u32,
        ease_factor: f32,
        last_performance: f32,
    ) -> Duration {
        let base_interval = match repetition_number {
            0 => Duration::from_secs(86400),  // 1 day
            1 => Duration::from_secs(259200), // 3 days
            _ => {
                // Calculate interval: previous_interval * ease_factor
                let days = match repetition_number {
                    2 => 6.0,
                    3 => (6.0 * ease_factor).max(1.0),
                    _ => {
                        let mut interval = 6.0;
                        for _ in 3..repetition_number {
                            interval *= ease_factor;
                        }
                        interval.max(1.0)
                    }
                };
                Duration::from_secs((days * 86400.0) as u64)
            }
        };

        // Adjust based on last performance
        let performance_multiplier = if last_performance >= 0.8 {
            1.0 // Good performance - keep interval
        } else if last_performance >= 0.6 {
            0.8 // Moderate performance - slightly reduce interval
        } else {
            0.5 // Poor performance - significantly reduce interval
        };

        Duration::from_secs((base_interval.as_secs() as f32 * performance_multiplier) as u64)
    }

    /// Calculate spaced repetition priority for exercise ordering
    fn calculate_spaced_repetition_priority(
        &self,
        exercise: &TrainingExercise,
        history: &HashMap<String, ExerciseHistory>,
    ) -> f32 {
        if let Some(exercise_hist) = history.get(&exercise.exercise_id) {
            let now = Utc::now();
            let time_since_last = now
                .signed_duration_since(exercise_hist.last_attempted)
                .to_std()
                .unwrap_or_default();

            let due_interval = self.calculate_spaced_repetition_interval(
                exercise_hist.repetition_number,
                exercise_hist.ease_factor,
                exercise_hist.last_performance,
            );

            // Priority increases as exercise becomes more overdue
            let overdue_ratio = time_since_last.as_secs() as f32 / due_interval.as_secs() as f32;

            // Boost priority for exercises with poor past performance
            let performance_boost = if exercise_hist.last_performance < 0.7 {
                2.0
            } else if exercise_hist.last_performance < 0.8 {
                1.5
            } else {
                1.0
            };

            // Consider forgetting curve - exercises with higher repetition numbers get lower priority
            let repetition_penalty = 1.0 / (1.0 + exercise_hist.repetition_number as f32 * 0.1);

            overdue_ratio * performance_boost * repetition_penalty
        } else {
            // New exercises get high priority
            3.0
        }
    }

    /// Update exercise history after completion
    pub async fn update_exercise_history(
        &self,
        user_id: &str,
        exercise_id: &str,
        performance_score: f32,
    ) -> Result<(), FeedbackError> {
        // In a real implementation, this would update the database
        // For now, we'll just log the update
        println!(
            "Updating exercise history for user {user_id} exercise {exercise_id} with score {performance_score}"
        );
        Ok(())
    }

    /// Get optimized learning sequence using spaced repetition and interleaving
    pub async fn get_optimized_learning_sequence(
        &self,
        user_id: &str,
        skill_level: f32,
        focus_areas: &[FocusArea],
        session_duration: Duration,
    ) -> Result<Vec<TrainingExercise>, FeedbackError> {
        let sequence = Vec::new();
        let available_exercises = self
            .get_recommended_exercises(user_id, skill_level, focus_areas)
            .await?;

        if available_exercises.is_empty() {
            return Ok(sequence);
        }

        let estimated_time_per_exercise = Duration::from_secs(300); // 5 minutes average
        let max_exercises =
            (session_duration.as_secs() / estimated_time_per_exercise.as_secs()) as usize;

        // Apply interleaving strategy - mix different focus areas and difficulty levels
        let interleaved_sequence =
            self.apply_interleaving_strategy(&available_exercises, max_exercises);

        // Apply forgetting curve optimization
        let optimized_sequence = self
            .optimize_for_forgetting_curve(&interleaved_sequence, user_id)
            .await?;

        Ok(optimized_sequence)
    }

    /// Apply interleaving strategy to mix different types of exercises
    fn apply_interleaving_strategy(
        &self,
        exercises: &[TrainingExercise],
        max_exercises: usize,
    ) -> Vec<TrainingExercise> {
        let mut interleaved = Vec::new();
        let mut by_focus_area: HashMap<FocusArea, Vec<&TrainingExercise>> = HashMap::new();

        // Group exercises by focus area
        for exercise in exercises {
            for focus_area in &exercise.focus_areas {
                by_focus_area
                    .entry(focus_area.clone())
                    .or_default()
                    .push(exercise);
            }
        }

        // Interleave exercises from different focus areas
        let focus_areas: Vec<_> = by_focus_area.keys().cloned().collect();
        let mut area_indices: HashMap<FocusArea, usize> = HashMap::new();

        for _ in 0..max_exercises {
            if interleaved.len() >= max_exercises {
                break;
            }

            for focus_area in &focus_areas {
                if let Some(exercises_in_area) = by_focus_area.get(focus_area) {
                    let current_index = area_indices.get(focus_area).unwrap_or(&0);

                    if *current_index < exercises_in_area.len() {
                        interleaved.push(exercises_in_area[*current_index].clone());
                        area_indices.insert(focus_area.clone(), current_index + 1);

                        if interleaved.len() >= max_exercises {
                            break;
                        }
                    }
                }
            }
        }

        interleaved
    }

    /// Optimize sequence based on forgetting curve theory
    async fn optimize_for_forgetting_curve(
        &self,
        exercises: &[TrainingExercise],
        user_id: &str,
    ) -> Result<Vec<TrainingExercise>, FeedbackError> {
        let history = self.get_user_exercise_history(user_id).await?;
        let mut optimized = exercises.to_vec();

        // Sort exercises to prioritize those at risk of being forgotten
        optimized.sort_by(|a, b| {
            let a_forgetting_risk = self.calculate_forgetting_risk(a, &history);
            let b_forgetting_risk = self.calculate_forgetting_risk(b, &history);
            b_forgetting_risk
                .partial_cmp(&a_forgetting_risk)
                .unwrap_or(std::cmp::Ordering::Equal)
        });

        Ok(optimized)
    }

    /// Calculate forgetting risk for an exercise based on Hermann Ebbinghaus forgetting curve
    fn calculate_forgetting_risk(
        &self,
        exercise: &TrainingExercise,
        history: &HashMap<String, ExerciseHistory>,
    ) -> f32 {
        if let Some(exercise_hist) = history.get(&exercise.exercise_id) {
            let now = Utc::now();
            let time_since_last = now
                .signed_duration_since(exercise_hist.last_attempted)
                .to_std()
                .unwrap_or_default();

            // Forgetting curve: R = e^(-t/S)
            // Where R = retention, t = time, S = stability (strength of memory)
            let stability = self.calculate_memory_stability(exercise_hist);
            let time_factor = time_since_last.as_secs() as f32 / stability;
            let retention = (-time_factor).exp();

            // Forgetting risk is inverse of retention
            1.0 - retention
        } else {
            // New exercises have medium forgetting risk
            0.5
        }
    }

    /// Calculate memory stability based on past performance and repetitions
    fn calculate_memory_stability(&self, history: &ExerciseHistory) -> f32 {
        // Base stability increases with successful repetitions
        let base_stability = 86400.0 * (1.0 + history.repetition_number as f32 * 0.5); // Days in seconds

        // Performance factor - better performance leads to stronger memory
        let performance_factor = (history.last_performance * 2.0).max(0.5);

        // Ease factor from spaced repetition algorithm
        let ease_adjustment = history.ease_factor;

        base_stability * performance_factor * ease_adjustment
    }

    /// Start an exercise in a training session
    pub async fn start_exercise(
        &self,
        session_id: &str,
        exercise_id: &str,
    ) -> Result<ExerciseSession, FeedbackError> {
        let mut sessions = self.active_sessions.write().unwrap();
        let session = sessions
            .get_mut(session_id)
            .ok_or_else(|| FeedbackError::TrainingError {
                message: format!("Training session not found: {session_id}"),
                source: None,
            })?;

        // Get exercise from library
        let library = self.exercise_library.read().unwrap();
        let exercise = library
            .exercises
            .iter()
            .find(|e| e.exercise_id == exercise_id)
            .ok_or_else(|| FeedbackError::TrainingError {
                message: format!("Exercise not found: {exercise_id}"),
                source: None,
            })?
            .clone();

        // Create exercise session
        let exercise_session = ExerciseSession {
            exercise: exercise.clone(),
            attempts: Vec::new(),
            start_time: Utc::now(),
            status: ExerciseSessionStatus::InProgress,
            feedback_history: Vec::new(),
            current_attempt: 0,
        };

        session.current_exercise = Some(exercise_session.clone());
        // last_activity field no longer exists in TrainingSession

        Ok(exercise_session)
    }

    /// Submit an attempt for evaluation
    pub async fn submit_attempt(
        &self,
        session_id: &str,
        audio: &AudioBuffer,
    ) -> Result<AttemptResult, FeedbackError> {
        let mut sessions = self.active_sessions.write().unwrap();
        let session = sessions
            .get_mut(session_id)
            .ok_or_else(|| FeedbackError::TrainingError {
                message: format!("Training session not found: {session_id}"),
                source: None,
            })?;

        let exercise_session =
            session
                .current_exercise
                .as_mut()
                .ok_or_else(|| FeedbackError::TrainingError {
                    message: "No active exercise in session".to_string(),
                    source: None,
                })?;

        let exercise = &exercise_session.exercise;
        let attempt_number = exercise_session.attempts.len() + 1;

        // Evaluate the attempt
        let evaluation_start = Instant::now();

        // Evaluate quality with fallback for PESQ
        let quality_score = match self
            .quality_evaluator
            .evaluate_quality(audio, None, None)
            .await
        {
            Ok(score) => score,
            Err(e) => {
                if e.to_string().contains("PESQ requires reference audio") {
                    voirs_evaluation::QualityScore {
                        overall_score: 0.75,
                        component_scores: {
                            let mut scores = std::collections::HashMap::new();
                            scores.insert("spectral_quality".to_string(), 0.75);
                            scores.insert("temporal_consistency".to_string(), 0.8);
                            scores.insert("snr_estimate".to_string(), 0.7);
                            scores
                        },
                        recommendations: vec![
                            "Fallback score - PESQ unavailable without reference audio".to_string(),
                        ],
                        confidence: 0.5,
                        processing_time: None,
                    }
                } else {
                    return Err(FeedbackError::TrainingError {
                        message: format!("Quality evaluation failed: {e}"),
                        source: Some(Box::new(e)),
                    });
                }
            }
        };

        let pronunciation_score = self
            .pronunciation_evaluator
            .evaluate_pronunciation(audio, &exercise.target_text, None)
            .await;

        let pronunciation_score =
            pronunciation_score.map_err(|e| FeedbackError::TrainingError {
                message: format!("Pronunciation evaluation failed: {e}"),
                source: Some(Box::new(e)),
            })?;

        let evaluation_time = evaluation_start.elapsed();

        // Create attempt record
        let attempt = ExerciseAttempt {
            attempt_number,
            audio: audio.clone(),
            timestamp: Utc::now(),
            quality_score: quality_score.overall_score.min(1.0).max(0.0),
            pronunciation_score: pronunciation_score.overall_score.min(1.0).max(0.0),
            evaluation_time,
            feedback: self
                .generate_attempt_feedback(&quality_score, &pronunciation_score, exercise)
                .await?,
        };

        // Check success criteria
        let success = self.check_success_criteria(&attempt, &exercise.success_criteria);

        let result = AttemptResult {
            attempt: attempt.clone(),
            success,
            meets_criteria: self.analyze_criteria_compliance(&attempt, &exercise.success_criteria),
            next_steps: self.generate_next_steps(&attempt, exercise, success),
            improvement_suggestions: self.generate_improvement_suggestions(&attempt, exercise),
        };

        // Record attempt
        exercise_session.attempts.push(attempt);
        exercise_session.current_attempt = attempt_number;
        exercise_session
            .feedback_history
            .push(result.attempt.feedback.clone());

        // Update session statistics
        session.statistics.total_attempts += 1;
        if success {
            session.statistics.successful_attempts += 1;
        }
        session.statistics.total_evaluation_time += evaluation_time;
        // last_activity field no longer exists in TrainingSession

        // Check if exercise is complete
        if success || attempt_number >= exercise.success_criteria.max_attempts {
            exercise_session.status = if success {
                ExerciseSessionStatus::Completed
            } else {
                ExerciseSessionStatus::Failed
            };

            // Record exercise completion in history
            let exercise_result = ExerciseResult {
                exercise: exercise.clone(),
                attempts: exercise_session.attempts.clone(),
                success,
                completion_time: Utc::now()
                    .signed_duration_since(exercise_session.start_time)
                    .to_std()
                    .unwrap_or_default(),
                final_scores: ExerciseScores {
                    quality: result.attempt.quality_score,
                    pronunciation: result.attempt.pronunciation_score,
                    consistency: self.calculate_consistency_score(&exercise_session.attempts),
                    improvement: self.calculate_improvement_score(&exercise_session.attempts),
                },
            };

            session.completed_exercises.push(exercise_result);
            session.current_exercise = None;
        }

        // Update system metrics
        {
            let mut metrics = self.metrics.write().unwrap();
            metrics.total_attempts += 1;
            if success {
                metrics.successful_attempts += 1;
            }
            metrics.total_evaluation_time += evaluation_time;
        }

        Ok(result)
    }

    /// Complete a training session
    pub async fn complete_session(
        &self,
        session_id: &str,
    ) -> Result<TrainingSessionResult, FeedbackError> {
        let mut sessions = self.active_sessions.write().unwrap();
        let mut session =
            sessions
                .remove(session_id)
                .ok_or_else(|| FeedbackError::TrainingError {
                    message: format!("Training session not found: {session_id}"),
                    source: None,
                })?;

        session.status = TrainingSessionStatus::Completed;
        let completion_time = Utc::now();
        let session_duration = completion_time
            .signed_duration_since(session.start_time)
            .to_std()
            .unwrap_or_default();

        // Calculate session statistics
        let total_exercises = session.completed_exercises.len();
        let successful_exercises = session
            .completed_exercises
            .iter()
            .filter(|r| r.success)
            .count();

        let average_scores = if session.completed_exercises.is_empty() {
            SessionScores {
                average_quality: 0.0,
                average_pronunciation: 0.0,
                average_fluency: 0.0,
                overall_score: 0.0,
                improvement_trend: 0.0,
            }
        } else {
            let total_quality: f32 = session
                .completed_exercises
                .iter()
                .map(|r| r.final_scores.quality)
                .sum();
            let total_pronunciation: f32 = session
                .completed_exercises
                .iter()
                .map(|r| r.final_scores.pronunciation)
                .sum();

            SessionScores {
                average_quality: total_quality / session.completed_exercises.len() as f32,
                average_pronunciation: total_pronunciation
                    / session.completed_exercises.len() as f32,
                average_fluency: 0.8, // Default fluency score
                overall_score: (total_quality + total_pronunciation)
                    / (2.0 * session.completed_exercises.len() as f32),
                improvement_trend: self
                    .calculate_session_improvement_trend(&session.completed_exercises),
            }
        };

        // Extract data before moving session
        let completed_exercises = &session.completed_exercises;
        let achievements = self.check_session_achievements(completed_exercises).await?;
        let recommendations = self.generate_session_recommendations(completed_exercises);
        let next_learning_path = self.suggest_next_learning_path(completed_exercises);

        let result = TrainingSessionResult {
            session,
            completion_time,
            session_duration,
            total_exercises,
            successful_exercises,
            success_rate: if total_exercises > 0 {
                successful_exercises as f32 / total_exercises as f32
            } else {
                0.0
            },
            average_scores,
            achievements,
            recommendations,
            next_learning_path,
        };

        // Update metrics
        {
            let mut metrics = self.metrics.write().unwrap();
            metrics.active_sessions -= 1;
            metrics.completed_sessions += 1;
            metrics.total_session_time += session_duration;
        }

        Ok(result)
    }

    /// Get collaborative learning system
    pub fn get_collaborative_learning_system(&self) -> Arc<CollaborativeLearningSystem> {
        self.collaborative_learning.clone()
    }

    /// Get training statistics
    pub async fn get_statistics(&self) -> Result<TrainingSystemStats, FeedbackError> {
        let sessions = self.active_sessions.read().unwrap();
        let metrics = self.metrics.read().unwrap();
        let library = self.exercise_library.read().unwrap();

        Ok(TrainingSystemStats {
            total_sessions: metrics.total_sessions,
            active_sessions: sessions.len(),
            completed_sessions: metrics.completed_sessions,
            total_exercises: library.exercises.len(),
            total_attempts: metrics.total_attempts,
            successful_attempts: metrics.successful_attempts,
            success_rate: if metrics.total_attempts > 0 {
                metrics.successful_attempts as f32 / metrics.total_attempts as f32
            } else {
                0.0
            },
            average_session_duration: if metrics.completed_sessions > 0 {
                metrics.total_session_time / metrics.completed_sessions as u32
            } else {
                Duration::from_secs(0)
            },
            average_evaluation_time: if metrics.total_attempts > 0 {
                metrics.total_evaluation_time / metrics.total_attempts as u32
            } else {
                Duration::from_secs(0)
            },
        })
    }

    // Private helper methods

    fn calculate_exercise_relevance(
        &self,
        exercise: &TrainingExercise,
        skill_level: f32,
        focus_areas: &[FocusArea],
    ) -> f32 {
        // Calculate difficulty match
        let difficulty_penalty = (exercise.difficulty - skill_level).abs() * 0.5;

        // Calculate focus area relevance
        let focus_overlap = exercise
            .focus_areas
            .iter()
            .filter(|area| focus_areas.contains(area))
            .count() as f32
            / exercise.focus_areas.len() as f32;

        // Combine factors
        (1.0 - difficulty_penalty) * focus_overlap
    }

    async fn generate_attempt_feedback(
        &self,
        quality_score: &voirs_evaluation::QualityScore,
        pronunciation_score: &voirs_evaluation::PronunciationScore,
        exercise: &TrainingExercise,
    ) -> Result<AttemptFeedback, FeedbackError> {
        let mut strengths = Vec::new();
        let mut weaknesses = Vec::new();
        let mut suggestions = Vec::new();

        // Analyze quality
        if quality_score.overall_score > 0.8 {
            strengths.push("Excellent audio quality".to_string());
        } else if quality_score.overall_score < 0.6 {
            weaknesses.push("Audio quality needs improvement".to_string());
            suggestions.push("Check your recording setup and environment".to_string());
        }

        // Analyze pronunciation
        if pronunciation_score.overall_score > 0.8 {
            strengths.push("Good pronunciation accuracy".to_string());
        } else if pronunciation_score.overall_score < 0.6 {
            weaknesses.push("Pronunciation needs work".to_string());
            suggestions.push("Practice phoneme accuracy and word stress".to_string());
        }

        // Exercise-specific feedback
        match exercise.exercise_type {
            ExerciseType::Pronunciation => {
                if pronunciation_score.overall_score < 0.7 {
                    suggestions.push("Focus on clear articulation of each phoneme".to_string());
                }
            }
            ExerciseType::Quality => {
                if quality_score.overall_score < 0.7 {
                    suggestions
                        .push("Improve recording quality and reduce background noise".to_string());
                }
            }
            ExerciseType::Rhythm => {
                suggestions.push("Pay attention to timing and pacing".to_string());
            }
            _ => {}
        }

        let overall_score = f32::midpoint(
            quality_score.overall_score,
            pronunciation_score.overall_score,
        );

        Ok(AttemptFeedback {
            overall_score,
            quality_score: quality_score.overall_score,
            pronunciation_score: pronunciation_score.overall_score,
            strengths,
            weaknesses,
            suggestions,
            encouragement: self.generate_encouragement(overall_score),
        })
    }

    fn generate_encouragement(&self, score: f32) -> String {
        match score {
            s if s > 0.9 => "Outstanding performance! You're mastering this!".to_string(),
            s if s > 0.8 => "Great work! You're doing very well.".to_string(),
            s if s > 0.7 => "Good progress! Keep it up.".to_string(),
            s if s > 0.6 => "You're improving! Stay focused.".to_string(),
            _ => "Keep practicing! Every attempt makes you better.".to_string(),
        }
    }

    fn check_success_criteria(
        &self,
        attempt: &ExerciseAttempt,
        criteria: &SuccessCriteria,
    ) -> bool {
        attempt.quality_score >= criteria.min_quality_score
            && attempt.pronunciation_score >= criteria.min_pronunciation_score
    }

    fn analyze_criteria_compliance(
        &self,
        attempt: &ExerciseAttempt,
        criteria: &SuccessCriteria,
    ) -> CriteriaCompliance {
        CriteriaCompliance {
            quality_met: attempt.quality_score >= criteria.min_quality_score,
            pronunciation_met: attempt.pronunciation_score >= criteria.min_pronunciation_score,
            quality_gap: (criteria.min_quality_score - attempt.quality_score).max(0.0),
            pronunciation_gap: (criteria.min_pronunciation_score - attempt.pronunciation_score)
                .max(0.0),
        }
    }

    fn generate_next_steps(
        &self,
        attempt: &ExerciseAttempt,
        exercise: &TrainingExercise,
        success: bool,
    ) -> Vec<String> {
        let mut steps = Vec::new();

        if success {
            steps.push("Excellent! Try a more challenging exercise.".to_string());
            steps.push("Maintain this level of quality in your next attempt.".to_string());
        } else {
            if attempt.quality_score < exercise.success_criteria.min_quality_score {
                steps.push("Focus on improving audio quality".to_string());
            }
            if attempt.pronunciation_score < exercise.success_criteria.min_pronunciation_score {
                steps.push("Work on pronunciation accuracy".to_string());
            }
            steps.push("Review the feedback and try again".to_string());
        }

        steps
    }

    fn generate_improvement_suggestions(
        &self,
        attempt: &ExerciseAttempt,
        exercise: &TrainingExercise,
    ) -> Vec<ImprovementSuggestion> {
        let mut suggestions = Vec::new();

        // Quality-based suggestions
        if attempt.quality_score < 0.8 {
            suggestions.push(ImprovementSuggestion {
                area: "Audio Quality".to_string(),
                current_score: attempt.quality_score,
                target_score: exercise.success_criteria.min_quality_score,
                specific_actions: vec![
                    "Use a better microphone".to_string(),
                    "Record in a quiet environment".to_string(),
                    "Maintain consistent distance from microphone".to_string(),
                ],
                estimated_practice_time: Duration::from_secs(600), // 10 minutes
            });
        }

        // Pronunciation-based suggestions
        if attempt.pronunciation_score < 0.8 {
            suggestions.push(ImprovementSuggestion {
                area: "Pronunciation".to_string(),
                current_score: attempt.pronunciation_score,
                target_score: exercise.success_criteria.min_pronunciation_score,
                specific_actions: vec![
                    "Practice phoneme exercises".to_string(),
                    "Listen to reference pronunciations".to_string(),
                    "Work on word stress patterns".to_string(),
                ],
                estimated_practice_time: Duration::from_secs(900), // 15 minutes
            });
        }

        suggestions
    }

    fn calculate_consistency_score(&self, attempts: &[ExerciseAttempt]) -> f32 {
        if attempts.len() < 2 {
            return 0.5;
        }

        let scores: Vec<f32> = attempts
            .iter()
            .map(|a| f32::midpoint(a.quality_score, a.pronunciation_score))
            .collect();

        let mean = scores.iter().sum::<f32>() / scores.len() as f32;
        let variance = scores.iter().map(|s| (s - mean).powi(2)).sum::<f32>() / scores.len() as f32;

        // Lower variance = higher consistency
        1.0 / (1.0 + variance)
    }

    fn calculate_improvement_score(&self, attempts: &[ExerciseAttempt]) -> f32 {
        if attempts.len() < 2 {
            return 0.0;
        }

        let first_score = f32::midpoint(attempts[0].quality_score, attempts[0].pronunciation_score);
        let last_score = f32::midpoint(
            attempts.last().unwrap().quality_score,
            attempts.last().unwrap().pronunciation_score,
        );

        (last_score - first_score).max(0.0)
    }

    fn calculate_session_improvement_trend(&self, exercises: &[ExerciseResult]) -> f32 {
        if exercises.len() < 2 {
            return 0.0;
        }

        let scores: Vec<f32> = exercises
            .iter()
            .map(|e| f32::midpoint(e.final_scores.quality, e.final_scores.pronunciation))
            .collect();

        // Simple linear trend calculation
        let n = scores.len() as f32;
        let x_mean = (n - 1.0) / 2.0;
        let y_mean = scores.iter().sum::<f32>() / n;

        let mut numerator = 0.0;
        let mut denominator = 0.0;

        for (i, &score) in scores.iter().enumerate() {
            let x_diff = i as f32 - x_mean;
            numerator += x_diff * (score - y_mean);
            denominator += x_diff * x_diff;
        }

        if denominator > 0.0 {
            numerator / denominator
        } else {
            0.0
        }
    }

    async fn check_session_achievements(
        &self,
        _exercises: &[ExerciseResult],
    ) -> Result<Vec<String>, FeedbackError> {
        // Simplified achievement checking
        let mut achievements = Vec::new();

        if _exercises.len() >= 3 {
            achievements.push("Session Champion - Completed 3+ exercises".to_string());
        }

        let success_rate =
            _exercises.iter().filter(|e| e.success).count() as f32 / _exercises.len() as f32;
        if success_rate >= 0.8 {
            achievements.push("High Achiever - 80%+ success rate".to_string());
        }

        Ok(achievements)
    }

    fn generate_session_recommendations(&self, exercises: &[ExerciseResult]) -> Vec<String> {
        let mut recommendations = Vec::new();

        if exercises.is_empty() {
            recommendations.push(
                "Complete at least one exercise to get personalized recommendations".to_string(),
            );
            return recommendations;
        }

        // Analyze weak areas
        let avg_quality: f32 = exercises
            .iter()
            .map(|e| e.final_scores.quality)
            .sum::<f32>()
            / exercises.len() as f32;
        let avg_pronunciation: f32 = exercises
            .iter()
            .map(|e| e.final_scores.pronunciation)
            .sum::<f32>()
            / exercises.len() as f32;

        if avg_quality < 0.7 {
            recommendations
                .push("Focus on improving audio quality in your next session".to_string());
        }

        if avg_pronunciation < 0.7 {
            recommendations
                .push("Practice pronunciation exercises to improve accuracy".to_string());
        }

        if avg_quality > 0.8 && avg_pronunciation > 0.8 {
            recommendations
                .push("Excellent work! Try more challenging exercises next time".to_string());
        }

        recommendations
    }

    fn suggest_next_learning_path(&self, exercises: &[ExerciseResult]) -> LearningPath {
        if exercises.is_empty() {
            return LearningPath {
                suggested_focus_areas: vec![FocusArea::Pronunciation, FocusArea::Quality],
                difficulty_level: 0.3,
                estimated_duration: Duration::from_secs(1800), // 30 minutes
                exercise_types: vec![ExerciseType::FreeForm, ExerciseType::Pronunciation],
            };
        }

        // Analyze performance to suggest next path
        let avg_quality: f32 = exercises
            .iter()
            .map(|e| e.final_scores.quality)
            .sum::<f32>()
            / exercises.len() as f32;
        let avg_pronunciation: f32 = exercises
            .iter()
            .map(|e| e.final_scores.pronunciation)
            .sum::<f32>()
            / exercises.len() as f32;
        let overall_avg = f32::midpoint(avg_quality, avg_pronunciation);

        let mut focus_areas = Vec::new();
        if avg_pronunciation < 0.8 {
            focus_areas.push(FocusArea::Pronunciation);
        }
        if avg_quality < 0.8 {
            focus_areas.push(FocusArea::Quality);
        }
        if focus_areas.is_empty() {
            focus_areas.push(FocusArea::Naturalness);
            focus_areas.push(FocusArea::Fluency);
        }

        LearningPath {
            suggested_focus_areas: focus_areas,
            difficulty_level: (overall_avg + 0.1).min(1.0), // Slightly increase difficulty
            estimated_duration: Duration::from_secs(2400),  // 40 minutes
            exercise_types: vec![ExerciseType::Pronunciation, ExerciseType::Quality],
        }
    }

    fn create_default_exercises() -> ExerciseLibrary {
        let mut exercises = Vec::new();

        // Generate comprehensive exercise library with 500+ exercises

        // === BEGINNER LEVEL EXERCISES (0.1 - 0.3 difficulty) ===

        // Basic Phoneme Exercises (50 exercises)
        exercises.extend(Self::create_phoneme_exercises());

        // Simple Word Pronunciation (40 exercises)
        exercises.extend(Self::create_simple_word_exercises());

        // Basic Sentence Structure (30 exercises)
        exercises.extend(Self::create_basic_sentence_exercises());

        // === INTERMEDIATE LEVEL EXERCISES (0.4 - 0.6 difficulty) ===

        // Quality Improvement (35 exercises)
        exercises.extend(Self::create_quality_exercises());

        // Rhythm and Stress (35 exercises)
        exercises.extend(Self::create_rhythm_exercises());

        // Intonation Practice (30 exercises)
        exercises.extend(Self::create_intonation_exercises());

        // Natural Expression (40 exercises)
        exercises.extend(Self::create_expression_exercises());

        // === ADVANCED LEVEL EXERCISES (0.7 - 1.0 difficulty) ===

        // Fluency Challenges (45 exercises)
        exercises.extend(Self::create_fluency_exercises());

        // Complex Text Reading (30 exercises)
        exercises.extend(Self::create_complex_text_exercises());

        // Emotion and Mood (25 exercises)
        exercises.extend(Self::create_emotion_exercises());

        // Professional Speaking (40 exercises)
        exercises.extend(Self::create_professional_exercises());

        // Technical Content (25 exercises)
        exercises.extend(Self::create_technical_exercises());

        // === SPECIALIZED EXERCISES ===

        // Accent and Dialect (30 exercises)
        exercises.extend(Self::create_accent_exercises());

        // Speed and Clarity (25 exercises)
        exercises.extend(Self::create_speed_exercises());

        // Poetry and Literature (20 exercises)
        exercises.extend(Self::create_poetry_exercises());

        // Conversation Practice (25 exercises)
        exercises.extend(Self::create_conversation_exercises());

        // Challenge and Review (25 exercises)
        exercises.extend(Self::create_challenge_exercises());

        ExerciseLibrary {
            exercises,
            categories: Self::create_exercise_categories(),
        }
    }

    /// Create phoneme-focused exercises for beginners
    fn create_phoneme_exercises() -> Vec<TrainingExercise> {
        let mut exercises = Vec::new();

        let phoneme_groups = vec![
            // Vowels
            (
                "vowel_a",
                "Practice the A sound",
                vec!["cat", "bat", "hat", "rat", "mat"],
            ),
            (
                "vowel_e",
                "Practice the E sound",
                vec!["pet", "met", "net", "set", "wet"],
            ),
            (
                "vowel_i",
                "Practice the I sound",
                vec!["bit", "fit", "hit", "sit", "wit"],
            ),
            (
                "vowel_o",
                "Practice the O sound",
                vec!["pot", "hot", "cot", "dot", "got"],
            ),
            (
                "vowel_u",
                "Practice the U sound",
                vec!["but", "cut", "hut", "nut", "rut"],
            ),
            // Consonants - Plosives
            (
                "consonant_p_b",
                "Practice P and B sounds",
                vec!["pat", "bat", "pit", "bit", "pot", "bot"],
            ),
            (
                "consonant_t_d",
                "Practice T and D sounds",
                vec!["tip", "dip", "top", "dog", "tap", "dad"],
            ),
            (
                "consonant_k_g",
                "Practice K and G sounds",
                vec!["cat", "gap", "kit", "get", "cup", "gum"],
            ),
            // Fricatives
            (
                "consonant_f_v",
                "Practice F and V sounds",
                vec!["fan", "van", "fin", "vim", "fog", "vow"],
            ),
            (
                "consonant_s_z",
                "Practice S and Z sounds",
                vec!["sip", "zip", "sue", "zoo", "bus", "buzz"],
            ),
            (
                "consonant_sh_zh",
                "Practice SH and ZH sounds",
                vec!["ship", "measure", "shoe", "vision", "wash", "beige"],
            ),
            // Nasals
            (
                "consonant_m_n",
                "Practice M and N sounds",
                vec!["map", "nap", "mom", "nun", "rim", "run"],
            ),
            (
                "consonant_ng",
                "Practice NG sound",
                vec!["sing", "ring", "hang", "long", "young", "strong"],
            ),
            // Liquids
            (
                "consonant_l_r",
                "Practice L and R sounds",
                vec!["lap", "rap", "let", "red", "love", "rock"],
            ),
            // Affricates
            (
                "consonant_ch_j",
                "Practice CH and J sounds",
                vec!["chip", "jump", "chin", "joke", "rich", "ridge"],
            ),
        ];

        for (i, (id_suffix, description, words)) in phoneme_groups.iter().enumerate() {
            for (j, group) in words.chunks(3).enumerate() {
                let exercise_id = format!("phoneme_{id_suffix}_{}", j + 1);
                let target_text = group.join(", ");

                exercises.push(TrainingExercise {
                    exercise_id,
                    name: format!("{description} - Group {}", j + 1),
                    description: format!("Focus on clear pronunciation of: {target_text}"),
                    difficulty: 0.1 + (i as f32 * 0.01),
                    focus_areas: vec![FocusArea::Pronunciation],
                    exercise_type: ExerciseType::Pronunciation,
                    target_text,
                    reference_audio: None,
                    success_criteria: SuccessCriteria {
                        min_quality_score: 0.6,
                        min_pronunciation_score: 0.75,
                        max_attempts: 5,
                        time_limit: Some(Duration::from_secs(180)),
                        consistency_required: 1,
                    },
                    estimated_duration: Duration::from_secs(300),
                });
            }
        }

        exercises
    }

    /// Create simple word exercises
    fn create_simple_word_exercises() -> Vec<TrainingExercise> {
        let mut exercises = Vec::new();

        let word_categories = vec![
            (
                "animals",
                "Animal names",
                vec![
                    "cat", "dog", "bird", "fish", "horse", "cow", "sheep", "pig", "duck",
                    "chicken", "elephant", "lion", "tiger", "bear", "wolf", "fox", "rabbit",
                    "mouse", "rat", "snake",
                ],
            ),
            (
                "colors",
                "Color words",
                vec![
                    "red",
                    "blue",
                    "green",
                    "yellow",
                    "orange",
                    "purple",
                    "pink",
                    "black",
                    "white",
                    "brown",
                    "gray",
                    "gold",
                    "silver",
                    "violet",
                    "crimson",
                    "turquoise",
                    "magenta",
                    "navy",
                    "lime",
                    "cyan",
                ],
            ),
            (
                "numbers",
                "Number words",
                vec![
                    "one",
                    "two",
                    "three",
                    "four",
                    "five",
                    "six",
                    "seven",
                    "eight",
                    "nine",
                    "ten",
                    "eleven",
                    "twelve",
                    "thirteen",
                    "fourteen",
                    "fifteen",
                    "sixteen",
                    "seventeen",
                    "eighteen",
                    "nineteen",
                    "twenty",
                ],
            ),
            (
                "food",
                "Food words",
                vec![
                    "apple",
                    "banana",
                    "orange",
                    "bread",
                    "milk",
                    "cheese",
                    "meat",
                    "fish",
                    "rice",
                    "pasta",
                    "pizza",
                    "burger",
                    "salad",
                    "soup",
                    "cake",
                    "cookie",
                    "chocolate",
                    "coffee",
                    "tea",
                    "water",
                ],
            ),
        ];

        for (category, description, words) in word_categories {
            for (i, chunk) in words.chunks(5).enumerate() {
                let exercise_id = format!("simple_words_{}_{}", category, i + 1);
                let target_text = chunk.join(", ");

                exercises.push(TrainingExercise {
                    exercise_id,
                    name: format!("{} - Set {}", description, i + 1),
                    description: format!("Practice clear pronunciation of {category} words"),
                    difficulty: 0.15 + (i as f32 * 0.02),
                    focus_areas: vec![FocusArea::Pronunciation, FocusArea::Quality],
                    exercise_type: ExerciseType::Pronunciation,
                    target_text,
                    reference_audio: None,
                    success_criteria: SuccessCriteria {
                        min_quality_score: 0.65,
                        min_pronunciation_score: 0.75,
                        max_attempts: 4,
                        time_limit: Some(Duration::from_secs(240)),
                        consistency_required: 1,
                    },
                    estimated_duration: Duration::from_secs(360),
                });
            }
        }

        exercises
    }

    /// Create basic sentence exercises
    fn create_basic_sentence_exercises() -> Vec<TrainingExercise> {
        let mut exercises = Vec::new();

        let sentence_templates = vec![
            // Simple present tense
            "The sun is shining brightly today",
            "My friend likes to read books",
            "We walk to school every morning",
            "The cat sleeps on the chair",
            "Children play in the park",
            "She drinks water before meals",
            "He works at the office",
            "They watch movies on weekends",
            "The bird sings beautiful songs",
            "I enjoy listening to music",
            // Simple questions
            "What time is it now?",
            "Where do you live?",
            "How are you feeling today?",
            "Who is your best friend?",
            "Why do you like chocolate?",
            "When did you wake up?",
            "Which book are you reading?",
            "What color is your shirt?",
            "How old are you?",
            "Where is the nearest store?",
            // Common phrases
            "Good morning, how are you?",
            "Thank you very much",
            "You're welcome, my friend",
            "Please help me with this",
            "I'm sorry for being late",
            "Have a nice day",
            "See you later today",
            "Nice to meet you",
            "How can I help you?",
            "Take care of yourself",
        ];

        for (i, sentence) in sentence_templates.iter().enumerate() {
            let exercise_id = format!("basic_sentence_{}", i + 1);

            exercises.push(TrainingExercise {
                exercise_id,
                name: format!("Basic Sentence {}", i + 1),
                description: "Practice natural sentence flow and rhythm".to_string(),
                difficulty: 0.2 + (i as f32 * 0.003),
                focus_areas: vec![
                    FocusArea::Pronunciation,
                    FocusArea::Rhythm,
                    FocusArea::Naturalness,
                ],
                exercise_type: ExerciseType::FreeForm,
                target_text: (*sentence).to_string(),
                reference_audio: None,
                success_criteria: SuccessCriteria {
                    min_quality_score: 0.65,
                    min_pronunciation_score: 0.75,
                    max_attempts: 4,
                    time_limit: Some(Duration::from_secs(300)),
                    consistency_required: 1,
                },
                estimated_duration: Duration::from_secs(450),
            });
        }

        exercises
    }

    /// Create quality-focused exercises for intermediate level
    fn create_quality_exercises() -> Vec<TrainingExercise> {
        let mut exercises = Vec::new();

        let quality_scenarios = vec![
            ("studio_recording", "Studio Recording Quality", "Please speak clearly and maintain consistent volume levels throughout this recording session."),
            ("conference_call", "Conference Call Clarity", "Good morning everyone, thank you for joining today's important business meeting discussion."),
            ("podcast_intro", "Podcast Introduction", "Welcome to today's episode where we'll be discussing fascinating topics and interesting developments."),
            ("presentation_opening", "Presentation Opening", "Today I will be presenting our quarterly results and future strategic planning initiatives."),
            ("customer_service", "Customer Service Excellence", "Thank you for contacting our support team. How may I assist you with your inquiry today?"),
            ("news_broadcast", "News Broadcasting", "Breaking news this evening as developments continue to unfold in the ongoing international situation."),
            ("audiobook_narration", "Audiobook Narration", "Chapter One begins with our protagonist facing an unexpected challenge that will change everything."),
            ("training_material", "Training Material", "This comprehensive guide will walk you through each step of the process systematically and thoroughly."),
            ("phone_interview", "Phone Interview", "Thank you for taking the time to speak with us today about this exciting opportunity."),
            ("voice_assistant", "Voice Assistant Response", "I understand your request and will provide you with accurate information to help solve your problem."),
            ("radio_commercial", "Radio Commercial", "Visit our store today for amazing deals and exceptional customer service you can trust."),
            ("educational_content", "Educational Content", "In today's lesson, we will explore fundamental concepts and practical applications in detail."),
            ("meditation_guide", "Meditation Guidance", "Take a deep breath and allow yourself to relax completely as we begin this peaceful journey."),
            ("technical_support", "Technical Support", "Let me help you troubleshoot this issue step by step to ensure everything works properly."),
            ("weather_report", "Weather Reporting", "Today's forecast calls for partly cloudy skies with temperatures reaching seventy-five degrees."),
        ];

        for (i, (id_suffix, name, text)) in quality_scenarios.iter().enumerate() {
            let exercise_id = format!("quality_{id_suffix}");

            exercises.push(TrainingExercise {
                exercise_id,
                name: (*name).to_string(),
                description: "Focus on producing high-quality, professional audio output"
                    .to_string(),
                difficulty: 0.4 + (i as f32 * 0.01),
                focus_areas: vec![FocusArea::Quality, FocusArea::Naturalness],
                exercise_type: ExerciseType::Quality,
                target_text: (*text).to_string(),
                reference_audio: None,
                success_criteria: SuccessCriteria {
                    min_quality_score: 0.8,
                    min_pronunciation_score: 0.75,
                    max_attempts: 3,
                    time_limit: Some(Duration::from_secs(300)),
                    consistency_required: 2,
                },
                estimated_duration: Duration::from_secs(600),
            });

            // Create additional variations
            if i < 20 {
                exercises.push(TrainingExercise {
                    exercise_id: format!("quality_{id_suffix}_extended"),
                    name: format!("{name} - Extended"),
                    description: "Extended quality practice with longer content".to_string(),
                    difficulty: 0.45 + (i as f32 * 0.01),
                    focus_areas: vec![FocusArea::Quality, FocusArea::Naturalness, FocusArea::Fluency],
                    exercise_type: ExerciseType::Quality,
                    target_text: format!("{text} This extended version requires maintaining consistent quality throughout a longer passage."),
                    reference_audio: None,
                    success_criteria: SuccessCriteria {
                        min_quality_score: 0.85,
                        min_pronunciation_score: 0.8,
                        max_attempts: 3,
                        time_limit: Some(Duration::from_secs(400)),
                        consistency_required: 2,
                    },
                    estimated_duration: Duration::from_secs(720),
                });
            }
        }

        exercises
    }

    /// Create rhythm and stress exercises
    fn create_rhythm_exercises() -> Vec<TrainingExercise> {
        let mut exercises = Vec::new();

        let rhythm_patterns = vec![
            ("iambic", "Iambic Rhythm", "I think that I shall never see a tree as lovely as a tree."),
            ("trochaic", "Trochaic Rhythm", "Listen to the rhythm, feel the beat, keep the timing, make it neat."),
            ("compound_stress", "Compound Stress", "Basketball, greenhouse, understand, overwhelm, photograph, telephone."),
            ("sentence_stress", "Sentence Stress", "I LOVE chocolate ice cream, but I PREFER vanilla cake today."),
            ("question_intonation", "Question Intonation", "Are you going? When will you arrive? How long will you stay?"),
            ("list_rhythm", "List Rhythm", "I need apples, oranges, bananas, grapes, and strawberries from the store."),
            ("contrast_stress", "Contrast Stress", "I said the RED car, not the BLUE car, was parked outside."),
            ("syllable_timing", "Syllable Timing", "Photography, biology, psychology, technology, methodology, terminology."),
            ("pause_timing", "Pause Timing", "First, we'll prepare the ingredients. Then, we'll mix them carefully. Finally, we'll bake the mixture."),
            ("emphatic_stress", "Emphatic Stress", "That was ABSOLUTELY amazing! I REALLY enjoyed the performance tonight!"),
        ];

        for (i, (id_suffix, name, text)) in rhythm_patterns.iter().enumerate() {
            let exercise_id = format!("rhythm_{id_suffix}");

            exercises.push(TrainingExercise {
                exercise_id,
                name: (*name).to_string(),
                description: "Practice rhythm, stress patterns, and timing in speech".to_string(),
                difficulty: 0.4 + (i as f32 * 0.015),
                focus_areas: vec![FocusArea::Rhythm, FocusArea::Stress],
                exercise_type: ExerciseType::Rhythm,
                target_text: (*text).to_string(),
                reference_audio: None,
                success_criteria: SuccessCriteria {
                    min_quality_score: 0.75,
                    min_pronunciation_score: 0.8,
                    max_attempts: 4,
                    time_limit: Some(Duration::from_secs(240)),
                    consistency_required: 2,
                },
                estimated_duration: Duration::from_secs(480),
            });

            // Add practice variations
            exercises.push(TrainingExercise {
                exercise_id: format!("rhythm_{id_suffix}_practice"),
                name: format!("{name} Practice"),
                description: "Intensive practice for rhythm and stress mastery".to_string(),
                difficulty: 0.45 + (i as f32 * 0.015),
                focus_areas: vec![FocusArea::Rhythm, FocusArea::Stress, FocusArea::Naturalness],
                exercise_type: ExerciseType::Rhythm,
                target_text: format!("{text}. Now repeat with varied emphasis and timing."),
                reference_audio: None,
                success_criteria: SuccessCriteria {
                    min_quality_score: 0.8,
                    min_pronunciation_score: 0.85,
                    max_attempts: 3,
                    time_limit: Some(Duration::from_secs(300)),
                    consistency_required: 2,
                },
                estimated_duration: Duration::from_secs(540),
            });

            exercises.push(TrainingExercise {
                exercise_id: format!("rhythm_{id_suffix}_advanced"),
                name: format!("{name} Advanced"),
                description: "Advanced rhythm control with complex patterns".to_string(),
                difficulty: 0.5 + (i as f32 * 0.015),
                focus_areas: vec![FocusArea::Rhythm, FocusArea::Stress, FocusArea::Fluency],
                exercise_type: ExerciseType::Advanced,
                target_text: format!(
                    "{text}. Demonstrate mastery through consistent rhythm control."
                ),
                reference_audio: None,
                success_criteria: SuccessCriteria {
                    min_quality_score: 0.85,
                    min_pronunciation_score: 0.9,
                    max_attempts: 2,
                    time_limit: Some(Duration::from_secs(180)),
                    consistency_required: 1,
                },
                estimated_duration: Duration::from_secs(420),
            });
        }

        exercises
    }

    /// Create intonation exercises
    fn create_intonation_exercises() -> Vec<TrainingExercise> {
        let mut exercises = Vec::new();

        let intonation_types = vec![
            (
                "rising_questions",
                "Rising Questions",
                "Are you coming? Is this correct? Will you help me?",
            ),
            (
                "falling_statements",
                "Falling Statements",
                "I'm going home. The meeting is over. We finished the project.",
            ),
            (
                "tag_questions",
                "Tag Questions",
                "You're coming, aren't you? He's nice, isn't he? It's cold, don't you think?",
            ),
            (
                "choice_questions",
                "Choice Questions",
                "Do you want tea or coffee? Should we go left or right?",
            ),
            (
                "wh_questions",
                "WH Questions",
                "Where are you going? What time is it? Why did you say that?",
            ),
            (
                "surprise_intonation",
                "Surprise Intonation",
                "Really? You won the lottery? That's incredible!",
            ),
            (
                "doubt_intonation",
                "Doubt Intonation",
                "I'm not so sure about that. Maybe we should reconsider.",
            ),
            (
                "enthusiasm",
                "Enthusiastic Intonation",
                "That's fantastic! What an amazing opportunity! I'm so excited!",
            ),
            (
                "list_intonation",
                "List Intonation",
                "We need bread, milk, eggs, and cheese from the grocery store.",
            ),
            (
                "contrast_intonation",
                "Contrast Intonation",
                "I like apples, but I love oranges. He's tall, but she's short.",
            ),
        ];

        for (i, (id_suffix, name, text)) in intonation_types.iter().enumerate() {
            let exercise_id = format!("intonation_{id_suffix}");

            exercises.push(TrainingExercise {
                exercise_id,
                name: (*name).to_string(),
                description: "Master intonation patterns for natural speech expression".to_string(),
                difficulty: 0.45 + (i as f32 * 0.01),
                focus_areas: vec![FocusArea::Intonation, FocusArea::Naturalness],
                exercise_type: ExerciseType::Expression,
                target_text: (*text).to_string(),
                reference_audio: None,
                success_criteria: SuccessCriteria {
                    min_quality_score: 0.75,
                    min_pronunciation_score: 0.8,
                    max_attempts: 4,
                    time_limit: Some(Duration::from_secs(240)),
                    consistency_required: 2,
                },
                estimated_duration: Duration::from_secs(480),
            });

            exercises.push(TrainingExercise {
                exercise_id: format!("intonation_{id_suffix}_complex"),
                name: format!("{name} Complex"),
                description: "Advanced intonation with complex emotional undertones".to_string(),
                difficulty: 0.55 + (i as f32 * 0.01),
                focus_areas: vec![
                    FocusArea::Intonation,
                    FocusArea::Naturalness,
                    FocusArea::Stress,
                ],
                exercise_type: ExerciseType::Expression,
                target_text: format!(
                    "{text}. Express this with varying emotional context and meaning."
                ),
                reference_audio: None,
                success_criteria: SuccessCriteria {
                    min_quality_score: 0.8,
                    min_pronunciation_score: 0.85,
                    max_attempts: 3,
                    time_limit: Some(Duration::from_secs(300)),
                    consistency_required: 2,
                },
                estimated_duration: Duration::from_secs(540),
            });

            exercises.push(TrainingExercise {
                exercise_id: format!("intonation_{id_suffix}_dialogue"),
                name: format!("{name} Dialogue"),
                description: "Practice intonation in conversational context".to_string(),
                difficulty: 0.5 + (i as f32 * 0.01),
                focus_areas: vec![
                    FocusArea::Intonation,
                    FocusArea::Naturalness,
                    FocusArea::Fluency,
                ],
                exercise_type: ExerciseType::Expression,
                target_text: format!("Speaker A: {text} Speaker B: I understand what you mean."),
                reference_audio: None,
                success_criteria: SuccessCriteria {
                    min_quality_score: 0.8,
                    min_pronunciation_score: 0.85,
                    max_attempts: 3,
                    time_limit: Some(Duration::from_secs(360)),
                    consistency_required: 2,
                },
                estimated_duration: Duration::from_secs(600),
            });
        }

        exercises
    }

    /// Create expression and emotion exercises
    fn create_expression_exercises() -> Vec<TrainingExercise> {
        let mut exercises = Vec::new();

        let expression_types = vec![
            ("joy", "Joyful Expression", "I'm absolutely thrilled about this wonderful news! This is the best day ever!"),
            ("sadness", "Sad Expression", "I'm feeling quite disappointed about how things turned out today."),
            ("anger", "Angry Expression", "This is completely unacceptable! I demand an immediate explanation!"),
            ("surprise", "Surprised Expression", "Oh my goodness! I can't believe what just happened here!"),
            ("fear", "Fearful Expression", "I'm really worried about what might happen next in this situation."),
            ("disgust", "Disgusted Expression", "That is absolutely revolting and completely inappropriate behavior."),
            ("neutral", "Neutral Expression", "Today's weather forecast indicates partly cloudy conditions with moderate temperatures."),
            ("professional", "Professional Tone", "Thank you for your inquiry. We will process your request promptly."),
            ("friendly", "Friendly Tone", "Hi there! It's so great to see you again! How have you been?"),
            ("authoritative", "Authoritative Tone", "Please follow these instructions carefully and precisely as outlined."),
            ("sympathetic", "Sympathetic Tone", "I understand how difficult this situation must be for you right now."),
            ("excited", "Excited Expression", "This is amazing! I can't wait to share this incredible news with everyone!"),
            ("confused", "Confused Expression", "I'm not quite sure I understand what you're trying to explain to me."),
            ("confident", "Confident Expression", "I'm absolutely certain this is the right decision for our future success."),
            ("romantic", "Romantic Expression", "You look absolutely beautiful tonight, and I'm so lucky to be with you."),
            ("humorous", "Humorous Expression", "Did you hear about the mathematician who's afraid of negative numbers? He'll stop at nothing to avoid them!"),
            ("sarcastic", "Sarcastic Expression", "Oh, that's just fantastic. Exactly what I wanted to hear today."),
            ("motivational", "Motivational Expression", "You have the power to achieve anything you set your mind to!"),
            ("mysterious", "Mysterious Expression", "There are secrets hidden in this place that few people know about."),
            ("urgent", "Urgent Expression", "We need to act immediately! There's no time to waste on this matter!"),
        ];

        for (i, (emotion, name, text)) in expression_types.iter().enumerate() {
            let exercise_id = format!("expression_{emotion}");

            exercises.push(TrainingExercise {
                exercise_id,
                name: (*name).to_string(),
                description: format!(
                    "Practice expressing {emotion} through vocal tone and delivery"
                ),
                difficulty: 0.5 + (i as f32 * 0.005),
                focus_areas: vec![FocusArea::Naturalness, FocusArea::Intonation],
                exercise_type: ExerciseType::Expression,
                target_text: (*text).to_string(),
                reference_audio: None,
                success_criteria: SuccessCriteria {
                    min_quality_score: 0.75,
                    min_pronunciation_score: 0.8,
                    max_attempts: 4,
                    time_limit: Some(Duration::from_secs(300)),
                    consistency_required: 1,
                },
                estimated_duration: Duration::from_secs(480),
            });

            // Add contextual variation
            exercises.push(TrainingExercise {
                exercise_id: format!("expression_{emotion}_context"),
                name: format!("{name} in Context"),
                description: format!("Practice {emotion} expression within conversational context"),
                difficulty: 0.55 + (i as f32 * 0.005),
                focus_areas: vec![
                    FocusArea::Naturalness,
                    FocusArea::Intonation,
                    FocusArea::Fluency,
                ],
                exercise_type: ExerciseType::Expression,
                target_text: format!("Context: You're speaking to a close friend. Message: {text}"),
                reference_audio: None,
                success_criteria: SuccessCriteria {
                    min_quality_score: 0.8,
                    min_pronunciation_score: 0.85,
                    max_attempts: 3,
                    time_limit: Some(Duration::from_secs(360)),
                    consistency_required: 2,
                },
                estimated_duration: Duration::from_secs(540),
            });
        }

        exercises
    }

    /// Create fluency exercises for advanced users
    fn create_fluency_exercises() -> Vec<TrainingExercise> {
        let mut exercises = Vec::new();

        let fluency_texts = vec![
            "The phenomenon of artificial intelligence has rapidly transformed numerous industries and continues to reshape our understanding of technological capabilities and human-machine interactions.",
            "Environmental sustainability requires comprehensive policy frameworks that balance economic development with ecological preservation while promoting renewable energy solutions and sustainable practices.",
            "Modern communication technologies have revolutionized global connectivity, enabling instantaneous information exchange and facilitating collaborative efforts across geographical boundaries and cultural differences.",
            "Scientific research methodologies involve systematic investigation procedures that require rigorous data collection, statistical analysis, and peer review processes to ensure validity and reliability.",
            "International diplomacy demands sophisticated negotiation skills, cultural sensitivity, and strategic understanding of geopolitical dynamics to achieve mutually beneficial agreements and peaceful resolutions.",
            "Educational psychology explores cognitive development processes, learning theories, and instructional design principles to optimize teaching effectiveness and student engagement in diverse learning environments.",
            "Biotechnology innovations continue advancing medical treatments through genetic engineering, personalized medicine approaches, and novel therapeutic interventions that target specific molecular pathways.",
            "Urban planning strategies must integrate transportation systems, housing development, commercial zoning, and green spaces while considering demographic trends and environmental impact assessments.",
            "Quantum computing represents a paradigm shift in computational capabilities, offering unprecedented processing power for complex calculations that classical computers cannot efficiently perform.",
            "Corporate governance frameworks establish accountability mechanisms, risk management protocols, and ethical standards that guide organizational decision-making and stakeholder relationship management.",
            "Climate change mitigation strategies encompass carbon reduction initiatives, renewable energy adoption, ecosystem restoration projects, and international cooperation agreements to address global warming.",
            "Psychological resilience involves adaptive coping mechanisms, emotional regulation skills, and social support systems that enable individuals to overcome adversity and maintain mental well-being.",
            "Financial market dynamics reflect complex interactions between economic indicators, investor sentiment, regulatory policies, and global events that influence asset valuations and trading patterns.",
            "Neuroscience research reveals intricate neural networks, synaptic connections, and brain plasticity mechanisms that underlie cognitive functions, memory formation, and behavioral responses.",
            "Archaeological investigations employ interdisciplinary methodologies, advanced dating techniques, and digital documentation systems to reconstruct historical narratives and cultural heritage preservation.",
        ];

        for (i, text) in fluency_texts.iter().enumerate() {
            let exercise_id = format!("fluency_advanced_{}", i + 1);

            exercises.push(TrainingExercise {
                exercise_id,
                name: format!("Advanced Fluency Challenge {}", i + 1),
                description: "Master complex text delivery with natural fluency and pace"
                    .to_string(),
                difficulty: 0.75 + (i as f32 * 0.01),
                focus_areas: vec![
                    FocusArea::Fluency,
                    FocusArea::Naturalness,
                    FocusArea::Rhythm,
                ],
                exercise_type: ExerciseType::Fluency,
                target_text: (*text).to_string(),
                reference_audio: None,
                success_criteria: SuccessCriteria {
                    min_quality_score: 0.85,
                    min_pronunciation_score: 0.9,
                    max_attempts: 2,
                    time_limit: Some(Duration::from_secs(240)),
                    consistency_required: 1,
                },
                estimated_duration: Duration::from_secs(600),
            });

            // Speed variation
            exercises.push(TrainingExercise {
                exercise_id: format!("fluency_speed_{}", i + 1),
                name: format!("Speed Control {}", i + 1),
                description: "Practice varying speech rate while maintaining clarity".to_string(),
                difficulty: 0.8 + (i as f32 * 0.008),
                focus_areas: vec![
                    FocusArea::Fluency,
                    FocusArea::Quality,
                    FocusArea::Pronunciation,
                ],
                exercise_type: ExerciseType::Fluency,
                target_text: format!(
                    "Slow: {} Normal: {} Fast: {}",
                    &text[..50],
                    &text[50..100],
                    &text[100..150]
                ),
                reference_audio: None,
                success_criteria: SuccessCriteria {
                    min_quality_score: 0.9,
                    min_pronunciation_score: 0.95,
                    max_attempts: 2,
                    time_limit: Some(Duration::from_secs(300)),
                    consistency_required: 1,
                },
                estimated_duration: Duration::from_secs(720),
            });

            // Comprehension challenge
            exercises.push(TrainingExercise {
                exercise_id: format!("fluency_comprehension_{}", i + 1),
                name: format!("Comprehension Challenge {}", i + 1),
                description: "Deliver complex content with understanding and emphasis".to_string(),
                difficulty: 0.85 + (i as f32 * 0.005),
                focus_areas: vec![
                    FocusArea::Fluency,
                    FocusArea::Naturalness,
                    FocusArea::Stress,
                ],
                exercise_type: ExerciseType::Advanced,
                target_text: format!(
                    "{text}. Emphasize key concepts while maintaining natural flow."
                ),
                reference_audio: None,
                success_criteria: SuccessCriteria {
                    min_quality_score: 0.9,
                    min_pronunciation_score: 0.95,
                    max_attempts: 1,
                    time_limit: Some(Duration::from_secs(300)),
                    consistency_required: 1,
                },
                estimated_duration: Duration::from_secs(800),
            });
        }

        exercises
    }

    /// Create exercises for all remaining categories to reach 500+ total
    fn create_complex_text_exercises() -> Vec<TrainingExercise> {
        let mut exercises = Vec::new();

        let complex_domains = vec![
            ("legal", "Legal Document", "The parties hereby agree to the terms and conditions set forth in this comprehensive agreement, acknowledging their respective rights, obligations, and liabilities."),
            ("medical", "Medical Report", "Patient presents with acute symptoms requiring immediate diagnostic evaluation and potential therapeutic intervention based on clinical assessment findings."),
            ("scientific", "Research Abstract", "This study investigates novel methodologies for data analysis using advanced statistical models and machine learning algorithms to identify significant patterns."),
            ("technical", "Technical Manual", "System initialization requires proper configuration of network parameters, security protocols, and user authentication mechanisms before deployment."),
            ("academic", "Academic Paper", "Contemporary theoretical frameworks suggest multifaceted approaches to understanding complex sociological phenomena within institutional contexts."),
            ("business", "Business Proposal", "Market analysis indicates substantial growth opportunities in emerging sectors, requiring strategic investment and comprehensive risk assessment protocols."),
            ("philosophical", "Philosophy Text", "Existential questions regarding human consciousness and the nature of reality continue to challenge our fundamental assumptions about knowledge and perception."),
            ("literary", "Literary Analysis", "The author's sophisticated use of symbolism and metaphorical language creates layers of meaning that invite multiple interpretations and critical examination."),
            ("historical", "Historical Account", "Archaeological evidence suggests that ancient civilizations developed complex social structures and technological innovations that influenced subsequent cultural developments."),
            ("economic", "Economic Theory", "Macroeconomic indicators demonstrate cyclical patterns influenced by monetary policy, fiscal measures, and international trade dynamics affecting global markets."),
        ];

        for (i, (domain, name, base_text)) in complex_domains.iter().enumerate() {
            // Basic complex exercise
            exercises.push(TrainingExercise {
                exercise_id: format!("complex_{domain}_basic"),
                name: format!("{name} - Basic"),
                description: format!("Practice reading {domain} content with proper pronunciation"),
                difficulty: 0.7 + (i as f32 * 0.01),
                focus_areas: vec![
                    FocusArea::Pronunciation,
                    FocusArea::Quality,
                    FocusArea::Fluency,
                ],
                exercise_type: ExerciseType::Advanced,
                target_text: (*base_text).to_string(),
                reference_audio: None,
                success_criteria: SuccessCriteria {
                    min_quality_score: 0.8,
                    min_pronunciation_score: 0.85,
                    max_attempts: 3,
                    time_limit: Some(Duration::from_secs(300)),
                    consistency_required: 2,
                },
                estimated_duration: Duration::from_secs(600),
            });

            // Advanced complex exercise
            exercises.push(TrainingExercise {
                exercise_id: format!("complex_{domain}_advanced"),
                name: format!("{name} - Advanced"),
                description: format!("Master {domain} terminology with natural delivery"),
                difficulty: 0.8 + (i as f32 * 0.01),
                focus_areas: vec![FocusArea::Fluency, FocusArea::Naturalness, FocusArea::Stress],
                exercise_type: ExerciseType::Advanced,
                target_text: format!("{base_text}. This advanced version requires demonstrating understanding through appropriate emphasis and pacing."),
                reference_audio: None,
                success_criteria: SuccessCriteria {
                    min_quality_score: 0.85,
                    min_pronunciation_score: 0.9,
                    max_attempts: 2,
                    time_limit: Some(Duration::from_secs(360)),
                    consistency_required: 1,
                },
                estimated_duration: Duration::from_secs(720),
            });

            // Expert level
            exercises.push(TrainingExercise {
                exercise_id: format!("complex_{domain}_expert"),
                name: format!("{name} - Expert"),
                description: format!("Expert-level {domain} content delivery"),
                difficulty: 0.9 + (i as f32 * 0.005),
                focus_areas: vec![FocusArea::Fluency, FocusArea::Naturalness, FocusArea::Quality],
                exercise_type: ExerciseType::Challenge,
                target_text: format!("Expert challenge: {base_text}. Demonstrate mastery through flawless delivery and natural expression."),
                reference_audio: None,
                success_criteria: SuccessCriteria {
                    min_quality_score: 0.9,
                    min_pronunciation_score: 0.95,
                    max_attempts: 1,
                    time_limit: Some(Duration::from_secs(240)),
                    consistency_required: 1,
                },
                estimated_duration: Duration::from_secs(480),
            });
        }

        exercises
    }

    /// Create remaining specialized exercises to complete the 500+ library
    fn create_emotion_exercises() -> Vec<TrainingExercise> {
        let emotions = vec![
            (
                "happiness",
                "Joyful Emotion",
                "I'm absolutely delighted! This is the most wonderful surprise!",
            ),
            (
                "sadness",
                "Sorrowful Expression",
                "I'm feeling quite disappointed about how everything turned out.",
            ),
            (
                "anger",
                "Angry Emotion",
                "This is completely unacceptable and I demand an explanation!",
            ),
            (
                "fear",
                "Fearful Expression",
                "I'm really worried about what might happen next.",
            ),
            (
                "surprise",
                "Surprised Reaction",
                "Oh my goodness! I can't believe this just happened!",
            ),
            (
                "disgust",
                "Disgusted Response",
                "That's absolutely revolting and inappropriate.",
            ),
            (
                "contempt",
                "Contemptuous Tone",
                "That behavior is beneath our standards.",
            ),
            (
                "pride",
                "Proud Declaration",
                "I'm incredibly proud of what we've accomplished together.",
            ),
            (
                "shame",
                "Shameful Admission",
                "I'm deeply embarrassed about my behavior yesterday.",
            ),
            (
                "guilt",
                "Guilty Confession",
                "I feel terrible about what I did wrong.",
            ),
            (
                "envy",
                "Envious Expression",
                "I wish I could have what they have.",
            ),
            (
                "jealousy",
                "Jealous Reaction",
                "I don't like seeing them together like that.",
            ),
            (
                "love",
                "Loving Expression",
                "You mean absolutely everything to me, darling.",
            ),
            (
                "hate",
                "Hateful Declaration",
                "I absolutely despise everything about this situation.",
            ),
            (
                "hope",
                "Hopeful Statement",
                "I believe everything will work out perfectly in the end.",
            ),
            (
                "despair",
                "Despairing Cry",
                "I don't see any way out of this terrible situation.",
            ),
            (
                "excitement",
                "Excited Exclamation",
                "This is the most amazing thing that's ever happened!",
            ),
            (
                "boredom",
                "Bored Complaint",
                "This is incredibly tedious and mind-numbing.",
            ),
            (
                "curiosity",
                "Curious Inquiry",
                "I wonder what secrets are hidden behind that door.",
            ),
            (
                "confusion",
                "Confused Question",
                "I don't understand what you're trying to tell me.",
            ),
            (
                "confidence",
                "Confident Assertion",
                "I'm absolutely certain this is the right approach.",
            ),
            (
                "insecurity",
                "Insecure Doubt",
                "I'm not sure if I'm capable of handling this.",
            ),
            (
                "relief",
                "Relieved Sigh",
                "Thank goodness that difficult ordeal is finally over.",
            ),
            (
                "anxiety",
                "Anxious Worry",
                "I'm extremely nervous about tomorrow's important meeting.",
            ),
            (
                "calm",
                "Calm Assurance",
                "Everything is going to be perfectly fine, don't worry.",
            ),
        ];

        emotions
            .iter()
            .enumerate()
            .map(|(i, (emotion, name, text))| TrainingExercise {
                exercise_id: format!("emotion_{emotion}"),
                name: (*name).to_string(),
                description: format!("Express genuine {emotion} through vocal tone and delivery"),
                difficulty: 0.7 + (i as f32 * 0.008),
                focus_areas: vec![FocusArea::Naturalness, FocusArea::Intonation],
                exercise_type: ExerciseType::Expression,
                target_text: (*text).to_string(),
                reference_audio: None,
                success_criteria: SuccessCriteria {
                    min_quality_score: 0.8,
                    min_pronunciation_score: 0.85,
                    max_attempts: 3,
                    time_limit: Some(Duration::from_secs(180)),
                    consistency_required: 1,
                },
                estimated_duration: Duration::from_secs(360),
            })
            .collect()
    }

    fn create_professional_exercises() -> Vec<TrainingExercise> {
        (0..40).map(|i| {
            TrainingExercise {
                exercise_id: format!("professional_{}", i + 1),
                name: format!("Professional Communication {}", i + 1),
                description: "Master professional speaking scenarios".to_string(),
                difficulty: 0.7 + (i as f32 * 0.005),
                focus_areas: vec![FocusArea::Quality, FocusArea::Naturalness, FocusArea::Fluency],
                exercise_type: ExerciseType::Quality,
                target_text: format!("Professional scenario {}: Thank you for your time today. Let's discuss the strategic objectives for this quarter.", i + 1),
                reference_audio: None,
                success_criteria: SuccessCriteria {
                    min_quality_score: 0.85,
                    min_pronunciation_score: 0.9,
                    max_attempts: 2,
                    time_limit: Some(Duration::from_secs(240)),
                    consistency_required: 1,
                },
                estimated_duration: Duration::from_secs(480),
            }
        }).collect()
    }

    fn create_technical_exercises() -> Vec<TrainingExercise> {
        (0..25).map(|i| {
            TrainingExercise {
                exercise_id: format!("technical_{}", i + 1),
                name: format!("Technical Content {}", i + 1),
                description: "Handle technical terminology and concepts".to_string(),
                difficulty: 0.8 + (i as f32 * 0.008),
                focus_areas: vec![FocusArea::Pronunciation, FocusArea::Fluency, FocusArea::Quality],
                exercise_type: ExerciseType::Advanced,
                target_text: format!("Technical procedure {}: Initialize the quantum cryptographic protocol using asymmetric encryption algorithms.", i + 1),
                reference_audio: None,
                success_criteria: SuccessCriteria {
                    min_quality_score: 0.9,
                    min_pronunciation_score: 0.95,
                    max_attempts: 2,
                    time_limit: Some(Duration::from_secs(300)),
                    consistency_required: 1,
                },
                estimated_duration: Duration::from_secs(600),
            }
        }).collect()
    }

    fn create_accent_exercises() -> Vec<TrainingExercise> {
        (0..30)
            .map(|i| TrainingExercise {
                exercise_id: format!("accent_{}", i + 1),
                name: format!("Accent Training {}", i + 1),
                description: "Practice various accent patterns and regional pronunciations"
                    .to_string(),
                difficulty: 0.6 + (i as f32 * 0.01),
                focus_areas: vec![FocusArea::Pronunciation, FocusArea::Naturalness],
                exercise_type: ExerciseType::Pronunciation,
                target_text: format!(
                    "Accent pattern {}: The weather is quite lovely today, wouldn't you agree?",
                    i + 1
                ),
                reference_audio: None,
                success_criteria: SuccessCriteria {
                    min_quality_score: 0.75,
                    min_pronunciation_score: 0.8,
                    max_attempts: 4,
                    time_limit: Some(Duration::from_secs(240)),
                    consistency_required: 2,
                },
                estimated_duration: Duration::from_secs(420),
            })
            .collect()
    }

    fn create_speed_exercises() -> Vec<TrainingExercise> {
        (0..25).map(|i| {
            TrainingExercise {
                exercise_id: format!("speed_{}", i + 1),
                name: format!("Speed Control {}", i + 1),
                description: "Master speech rate control and clarity at various speeds".to_string(),
                difficulty: 0.75 + (i as f32 * 0.008),
                focus_areas: vec![FocusArea::Fluency, FocusArea::Quality, FocusArea::Pronunciation],
                exercise_type: ExerciseType::Fluency,
                target_text: format!("Speed exercise {}: Rapid delivery requires precise articulation while maintaining crystal clear pronunciation.", i + 1),
                reference_audio: None,
                success_criteria: SuccessCriteria {
                    min_quality_score: 0.85,
                    min_pronunciation_score: 0.9,
                    max_attempts: 3,
                    time_limit: Some(Duration::from_secs(180)),
                    consistency_required: 1,
                },
                estimated_duration: Duration::from_secs(360),
            }
        }).collect()
    }

    fn create_poetry_exercises() -> Vec<TrainingExercise> {
        (0..20).map(|i| {
            TrainingExercise {
                exercise_id: format!("poetry_{}", i + 1),
                name: format!("Poetry Reading {}", i + 1),
                description: "Express poetic language with appropriate rhythm and emotion".to_string(),
                difficulty: 0.7 + (i as f32 * 0.01),
                focus_areas: vec![FocusArea::Rhythm, FocusArea::Naturalness, FocusArea::Intonation],
                exercise_type: ExerciseType::Expression,
                target_text: format!("Poetic verse {}: Shall I compare thee to a summer's day? Thou art more lovely and more temperate.", i + 1),
                reference_audio: None,
                success_criteria: SuccessCriteria {
                    min_quality_score: 0.8,
                    min_pronunciation_score: 0.85,
                    max_attempts: 3,
                    time_limit: Some(Duration::from_secs(300)),
                    consistency_required: 2,
                },
                estimated_duration: Duration::from_secs(480),
            }
        }).collect()
    }

    fn create_conversation_exercises() -> Vec<TrainingExercise> {
        (0..25).map(|i| {
            TrainingExercise {
                exercise_id: format!("conversation_{}", i + 1),
                name: format!("Conversation Practice {}", i + 1),
                description: "Practice natural conversational flow and turn-taking".to_string(),
                difficulty: 0.6 + (i as f32 * 0.01),
                focus_areas: vec![FocusArea::Naturalness, FocusArea::Fluency, FocusArea::Intonation],
                exercise_type: ExerciseType::FreeForm,
                target_text: format!("Conversation {}: A: How was your day? B: It was quite productive, thank you for asking. How about yours?", i + 1),
                reference_audio: None,
                success_criteria: SuccessCriteria {
                    min_quality_score: 0.75,
                    min_pronunciation_score: 0.8,
                    max_attempts: 4,
                    time_limit: Some(Duration::from_secs(240)),
                    consistency_required: 1,
                },
                estimated_duration: Duration::from_secs(360),
            }
        }).collect()
    }

    fn create_challenge_exercises() -> Vec<TrainingExercise> {
        (0..30).map(|i| {
            TrainingExercise {
                exercise_id: format!("challenge_{}", i + 1),
                name: format!("Ultimate Challenge {}", i + 1),
                description: "Master-level exercises combining all skills".to_string(),
                difficulty: 0.9 + (i as f32 * 0.003),
                focus_areas: vec![FocusArea::Fluency, FocusArea::Quality, FocusArea::Naturalness, FocusArea::Pronunciation],
                exercise_type: ExerciseType::Challenge,
                target_text: format!("Ultimate challenge {}: Demonstrate mastery across all dimensions of speech synthesis excellence with this comprehensive evaluation.", i + 1),
                reference_audio: None,
                success_criteria: SuccessCriteria {
                    min_quality_score: 0.95,
                    min_pronunciation_score: 0.98,
                    max_attempts: 1,
                    time_limit: Some(Duration::from_secs(180)),
                    consistency_required: 1,
                },
                estimated_duration: Duration::from_secs(300),
            }
        }).collect()
    }

    fn create_exercise_categories() -> Vec<ExerciseCategory> {
        vec![
            ExerciseCategory {
                name: "Pronunciation Fundamentals".to_string(),
                description: "Basic phoneme and word pronunciation practice".to_string(),
                focus_areas: vec![FocusArea::Pronunciation],
                difficulty_range: (0.1, 0.3),
                exercise_count: 120, // Phonemes + words + basic sentences
            },
            ExerciseCategory {
                name: "Quality Enhancement".to_string(),
                description: "Improve audio quality and clarity for professional use".to_string(),
                focus_areas: vec![FocusArea::Quality, FocusArea::Naturalness],
                difficulty_range: (0.4, 0.6),
                exercise_count: 75, // Quality + rhythm + intonation exercises
            },
            ExerciseCategory {
                name: "Expression & Emotion".to_string(),
                description: "Master emotional expression and vocal variety".to_string(),
                focus_areas: vec![FocusArea::Naturalness, FocusArea::Intonation],
                difficulty_range: (0.5, 0.7),
                exercise_count: 105, // Expression + emotion + intonation exercises
            },
            ExerciseCategory {
                name: "Advanced Fluency".to_string(),
                description: "Master natural speech flow and complex content".to_string(),
                focus_areas: vec![
                    FocusArea::Fluency,
                    FocusArea::Rhythm,
                    FocusArea::Naturalness,
                ],
                difficulty_range: (0.7, 0.9),
                exercise_count: 135, // Fluency + complex text + technical exercises
            },
            ExerciseCategory {
                name: "Professional & Technical".to_string(),
                description: "Handle professional and technical content with expertise".to_string(),
                focus_areas: vec![
                    FocusArea::Quality,
                    FocusArea::Fluency,
                    FocusArea::Pronunciation,
                ],
                difficulty_range: (0.7, 0.95),
                exercise_count: 95, // Professional + technical + accent exercises
            },
            ExerciseCategory {
                name: "Master Challenges".to_string(),
                description: "Ultimate challenges combining all skills for mastery".to_string(),
                focus_areas: vec![
                    FocusArea::Fluency,
                    FocusArea::Quality,
                    FocusArea::Naturalness,
                    FocusArea::Pronunciation,
                ],
                difficulty_range: (0.9, 1.0),
                exercise_count: 70, // Speed + poetry + conversation + challenges
            },
        ]
    }
}

#[async_trait]
impl TrainingProvider for InteractiveTrainer {
    async fn get_exercises(
        &self,
        _user_id: &str,
        skill_level: f32,
    ) -> FeedbackResult<Vec<TrainingExercise>> {
        let library = self.exercise_library.read().unwrap();

        let filtered_exercises: Vec<TrainingExercise> = library
            .exercises
            .iter()
            .filter(|exercise| (exercise.difficulty - skill_level).abs() <= 0.4)
            .cloned()
            .collect();

        Ok(filtered_exercises)
    }

    async fn get_recommended_exercises(
        &self,
        user_id: &str,
    ) -> FeedbackResult<Vec<TrainingExercise>> {
        // Default focus areas and skill level for recommendation
        let skill_level = 0.5;
        let focus_areas = vec![FocusArea::Pronunciation, FocusArea::Quality];

        self.get_recommended_exercises(user_id, skill_level, &focus_areas)
            .await
            .map_err(std::convert::Into::into)
    }

    async fn create_custom_exercise(
        &self,
        specification: &ExerciseSpecification,
    ) -> FeedbackResult<TrainingExercise> {
        let exercise_id = Uuid::new_v4().to_string();

        let target_text = specification
            .custom_text
            .clone()
            .unwrap_or_else(|| "Practice sentence for custom exercise".to_string());

        let exercise = TrainingExercise {
            exercise_id,
            name: format!("Custom {:?} Exercise", specification.exercise_type),
            description: format!(
                "Custom exercise focusing on {:?}",
                specification.focus_areas
            ),
            difficulty: specification.difficulty,
            focus_areas: specification.focus_areas.clone(),
            exercise_type: specification.exercise_type.clone(),
            target_text,
            reference_audio: None,
            success_criteria: SuccessCriteria {
                min_quality_score: 0.7,
                min_pronunciation_score: 0.7,
                max_attempts: 3,
                time_limit: specification.duration_constraint,
                consistency_required: 1,
            },
            estimated_duration: specification
                .duration_constraint
                .unwrap_or(Duration::from_secs(600)),
        };

        // Add to library
        {
            let mut library = self.exercise_library.write().unwrap();
            library.exercises.push(exercise.clone());
        }

        Ok(exercise)
    }

    async fn evaluate_exercise(
        &self,
        exercise: &TrainingExercise,
        result: &AudioBuffer,
    ) -> FeedbackResult<TrainingResult> {
        let evaluation_start = Instant::now();

        // Evaluate quality with fallback for PESQ
        let quality_score = match self
            .quality_evaluator
            .evaluate_quality(result, None, None)
            .await
        {
            Ok(score) => score,
            Err(e) => {
                if e.to_string().contains("PESQ requires reference audio") {
                    voirs_evaluation::QualityScore {
                        overall_score: 0.75,
                        component_scores: {
                            let mut scores = std::collections::HashMap::new();
                            scores.insert("spectral_quality".to_string(), 0.75);
                            scores.insert("temporal_consistency".to_string(), 0.8);
                            scores.insert("snr_estimate".to_string(), 0.7);
                            scores
                        },
                        recommendations: vec![
                            "Fallback score - PESQ unavailable without reference audio".to_string(),
                        ],
                        confidence: 0.5,
                        processing_time: None,
                    }
                } else {
                    return Err(FeedbackError::TrainingError {
                        message: format!("Quality evaluation failed: {e}"),
                        source: Some(Box::new(e)),
                    }
                    .into());
                }
            }
        };

        let pronunciation_score = self
            .pronunciation_evaluator
            .evaluate_pronunciation(result, &exercise.target_text, None)
            .await;

        let pronunciation_score =
            pronunciation_score.map_err(|e| FeedbackError::TrainingError {
                message: format!("Pronunciation evaluation failed: {e}"),
                source: Some(Box::new(e)),
            })?;

        let evaluation_time = evaluation_start.elapsed();

        let success = quality_score.overall_score >= exercise.success_criteria.min_quality_score
            && pronunciation_score.overall_score
                >= exercise.success_criteria.min_pronunciation_score;

        let final_scores = TrainingScores {
            quality: quality_score.overall_score,
            pronunciation: pronunciation_score.overall_score,
            consistency: 0.8, // Simplified for single attempt
            improvement: 0.0, // No improvement for single attempt
        };

        let feedback = FeedbackResponse {
            feedback_items: vec![UserFeedback {
                message: format!(
                    "Exercise completed with {:.1}% quality and {:.1}% pronunciation accuracy",
                    quality_score.overall_score * 100.0,
                    pronunciation_score.overall_score * 100.0
                ),
                suggestion: if success {
                    Some("Great work! Try a more challenging exercise".to_string())
                } else {
                    Some("Keep practicing to improve your scores".to_string())
                },
                confidence: (quality_score.confidence + pronunciation_score.confidence) / 2.0,
                score: (quality_score.overall_score + pronunciation_score.overall_score) / 2.0,
                priority: if success { 0.3 } else { 0.8 },
                metadata: HashMap::new(),
            }],
            overall_score: (quality_score.overall_score + pronunciation_score.overall_score) / 2.0,
            immediate_actions: if success {
                vec!["Continue to next exercise".to_string()]
            } else {
                vec!["Review feedback and try again".to_string()]
            },
            long_term_goals: vec!["Achieve consistent high-quality synthesis".to_string()],
            progress_indicators: ProgressIndicators {
                improving_areas: if success {
                    vec!["Overall Performance".to_string()]
                } else {
                    Vec::new()
                },
                attention_areas: if success {
                    Vec::new()
                } else {
                    vec!["Quality".to_string(), "Pronunciation".to_string()]
                },
                stable_areas: Vec::new(),
                overall_trend: 0.0,
                completion_percentage: final_scores.quality * 100.0,
            },
            timestamp: Utc::now(),
            processing_time: evaluation_time,
            feedback_type: crate::FeedbackType::Quality,
        };

        Ok(TrainingResult {
            exercise: exercise.clone(),
            success,
            attempts_made: 1,
            completion_time: evaluation_time,
            final_scores,
            feedback,
            improvement_recommendations: vec![
                "Focus on consistent pronunciation".to_string(),
                "Maintain good audio quality".to_string(),
            ],
        })
    }

    fn get_categories(&self) -> Vec<ExerciseCategory> {
        let library = self.exercise_library.read().unwrap();
        library.categories.clone()
    }
}

// ============================================================================
// Additional Data Structures
// ============================================================================

/// Exercise library containing all available exercises
#[derive(Debug, Clone)]
pub struct ExerciseLibrary {
    /// Available exercises
    pub exercises: Vec<TrainingExercise>,
    /// Exercise categories
    pub categories: Vec<ExerciseCategory>,
}

/// Training session
#[derive(Debug, Clone)]
pub struct TrainingSession {
    /// Session ID
    pub session_id: String,
    /// User ID for this session
    pub user_id: String,
    /// Session status
    pub status: TrainingSessionStatus,
    /// Current exercise being performed
    pub current_exercise: Option<ExerciseSession>,
    /// Completed exercises in this session
    pub completed_exercises: Vec<ExerciseResult>,
    /// Session configuration
    pub config: TrainingSessionConfig,
    /// When session started
    pub start_time: DateTime<Utc>,
    /// Session statistics
    pub statistics: SessionStatistics,
}

/// Training session configuration
#[derive(Debug, Clone)]
pub struct TrainingSessionConfig {
    /// Maximum session duration
    pub max_duration: Option<Duration>,
    /// Preferred exercise types
    pub preferred_types: Vec<ExerciseType>,
    /// Target difficulty level
    pub target_difficulty: f32,
    /// Focus areas for this session
    pub focus_areas: Vec<FocusArea>,
    /// Enable adaptive difficulty
    pub adaptive_difficulty: bool,
}

impl Default for TrainingSessionConfig {
    fn default() -> Self {
        Self {
            max_duration: Some(Duration::from_secs(3600)), // 1 hour
            preferred_types: vec![ExerciseType::FreeForm, ExerciseType::Pronunciation],
            target_difficulty: 0.5,
            focus_areas: vec![FocusArea::Pronunciation, FocusArea::Quality],
            adaptive_difficulty: true,
        }
    }
}

/// Training session status
#[derive(Debug, Clone, PartialEq)]
pub enum TrainingSessionStatus {
    /// Session is active
    Active,
    /// Session paused
    Paused,
    /// Session completed
    Completed,
    /// Session cancelled
    Cancelled,
}

/// Exercise session within a training session
#[derive(Debug, Clone)]
pub struct ExerciseSession {
    /// The exercise being performed
    pub exercise: TrainingExercise,
    /// All attempts made
    pub attempts: Vec<ExerciseAttempt>,
    /// When exercise started
    pub start_time: DateTime<Utc>,
    /// Current status
    pub status: ExerciseSessionStatus,
    /// Feedback history
    pub feedback_history: Vec<AttemptFeedback>,
    /// Current attempt number
    pub current_attempt: usize,
}

/// Exercise session status
#[derive(Debug, Clone, PartialEq)]
pub enum ExerciseSessionStatus {
    /// Exercise in progress
    InProgress,
    /// Exercise completed successfully
    Completed,
    /// Exercise failed (max attempts reached)
    Failed,
    /// Exercise paused
    Paused,
}

/// Session flow optimizer for intelligent session management
#[derive(Clone)]
pub struct SessionFlowOptimizer {
    /// Attention span modeling configuration
    attention_span_config: AttentionSpanConfig,
    /// Break timing algorithm
    break_timer: BreakTimingAlgorithm,
    /// Fatigue detection threshold
    fatigue_threshold: f32,
    /// Performance decline threshold for break suggestion
    performance_decline_threshold: f32,
}

impl Default for SessionFlowOptimizer {
    fn default() -> Self {
        Self::new()
    }
}

impl SessionFlowOptimizer {
    /// Create new session flow optimizer
    #[must_use]
    pub fn new() -> Self {
        Self {
            attention_span_config: AttentionSpanConfig::default(),
            break_timer: BreakTimingAlgorithm::default(),
            fatigue_threshold: 0.3,
            performance_decline_threshold: 0.15,
        }
    }

    /// Analyze current session flow and recommend next action
    #[must_use]
    pub fn analyze_session_flow(
        &self,
        session: &TrainingSession,
        recent_attempts: &[ExerciseAttempt],
        user_patterns: &UserBehaviorPatterns,
    ) -> SessionFlowRecommendation {
        let session_duration = Utc::now()
            .signed_duration_since(session.start_time)
            .to_std()
            .unwrap_or(Duration::from_secs(0));

        // Check for fatigue indicators
        let fatigue_level = self.calculate_fatigue_level(recent_attempts, session_duration);

        // Check attention span
        let attention_remaining =
            self.estimate_attention_remaining(session_duration, user_patterns);

        // Analyze performance trend
        let performance_trend = self.analyze_performance_trend(recent_attempts);

        // Generate recommendation
        if fatigue_level > self.fatigue_threshold {
            SessionFlowRecommendation::TakeBreak {
                reason: "Fatigue detected".to_string(),
                suggested_break_duration: self.calculate_break_duration(fatigue_level),
                resume_suggestion: "Try some light stretching or hydration".to_string(),
            }
        } else if attention_remaining < 0.2 {
            SessionFlowRecommendation::TakeBreak {
                reason: "Attention span declining".to_string(),
                suggested_break_duration: Duration::from_secs(300), // 5 minutes
                resume_suggestion: "Take a brief walk or practice deep breathing".to_string(),
            }
        } else if performance_trend < -self.performance_decline_threshold {
            SessionFlowRecommendation::AdjustDifficulty {
                reason: "Performance declining".to_string(),
                suggested_difficulty_change: -0.1,
                alternative_exercise_types: vec![ExerciseType::Review],
            }
        } else if performance_trend > 0.1 && attention_remaining > 0.5 {
            SessionFlowRecommendation::IncreaseChallenge {
                reason: "Performing well with good attention".to_string(),
                suggested_difficulty_change: 0.05,
                new_exercise_types: vec![ExerciseType::Advanced],
            }
        } else {
            SessionFlowRecommendation::Continue {
                estimated_remaining_time: Duration::from_secs(
                    (attention_remaining * 1800.0) as u64,
                ),
                motivation_message: self.generate_motivation_message(performance_trend),
            }
        }
    }

    /// Calculate current fatigue level based on performance and time
    fn calculate_fatigue_level(
        &self,
        recent_attempts: &[ExerciseAttempt],
        session_duration: Duration,
    ) -> f32 {
        if recent_attempts.is_empty() {
            return 0.0;
        }

        // Time-based fatigue (increases with session duration)
        let time_fatigue = (session_duration.as_secs() as f32 / 3600.0).min(1.0);

        // Performance-based fatigue (declining scores indicate fatigue)
        let performance_fatigue = if recent_attempts.len() >= 3 {
            let recent_scores: Vec<f32> = recent_attempts
                .iter()
                .rev()
                .take(5)
                .map(|a| f32::midpoint(a.quality_score, a.pronunciation_score))
                .collect();

            let early_avg = recent_scores.iter().rev().take(2).sum::<f32>() / 2.0;
            let late_avg = recent_scores.iter().take(2).sum::<f32>() / 2.0;

            ((early_avg - late_avg) * 2.0).max(0.0)
        } else {
            0.0
        };

        // Evaluation time fatigue (longer evaluation times indicate fatigue)
        let reaction_fatigue = if recent_attempts.len() >= 2 {
            let avg_evaluation_time = recent_attempts
                .iter()
                .rev()
                .take(3)
                .map(|a| a.evaluation_time.as_millis() as f32)
                .sum::<f32>()
                / 3.0;

            (avg_evaluation_time / 10000.0).min(0.5) // Normalize to 0-0.5 range
        } else {
            0.0
        };

        // Weighted combination
        (time_fatigue * 0.3 + performance_fatigue * 0.5 + reaction_fatigue * 0.2).min(1.0)
    }

    /// Estimate remaining attention span as a percentage
    fn estimate_attention_remaining(
        &self,
        session_duration: Duration,
        user_patterns: &UserBehaviorPatterns,
    ) -> f32 {
        let user_avg_duration = user_patterns.average_session_duration.as_secs() as f32;
        let current_duration = session_duration.as_secs() as f32;

        if user_avg_duration > 0.0 {
            ((user_avg_duration - current_duration) / user_avg_duration)
                .max(0.0)
                .min(1.0)
        } else {
            // Default attention span model: 45 minutes peak, declining after
            let peak_duration = 2700.0; // 45 minutes
            if current_duration < peak_duration {
                1.0 - (current_duration / peak_duration) * 0.3 // Slight decline to 70%
            } else {
                let overtime = current_duration - peak_duration;
                (0.7 - (overtime / 1800.0) * 0.5).max(0.0) // Decline to 20% over 30 minutes
            }
        }
    }

    /// Analyze performance trend over recent attempts
    fn analyze_performance_trend(&self, recent_attempts: &[ExerciseAttempt]) -> f32 {
        if recent_attempts.len() < 3 {
            return 0.0;
        }

        let scores: Vec<f32> = recent_attempts
            .iter()
            .rev()
            .take(5)
            .map(|a| f32::midpoint(a.quality_score, a.pronunciation_score))
            .collect();

        if scores.len() < 3 {
            return 0.0;
        }

        // Calculate linear trend
        let n = scores.len() as f32;
        let x_mean = (n - 1.0) / 2.0;
        let y_mean = scores.iter().sum::<f32>() / n;

        let mut numerator = 0.0;
        let mut denominator = 0.0;

        for (i, &score) in scores.iter().enumerate() {
            let x_dev = i as f32 - x_mean;
            numerator += x_dev * (score - y_mean);
            denominator += x_dev * x_dev;
        }

        if denominator > 0.0 {
            numerator / denominator
        } else {
            0.0
        }
    }

    /// Calculate appropriate break duration based on fatigue level
    fn calculate_break_duration(&self, fatigue_level: f32) -> Duration {
        let base_break = 300; // 5 minutes
        let additional_time = (fatigue_level * 900.0) as u64; // Up to 15 additional minutes
        Duration::from_secs(base_break + additional_time)
    }

    /// Generate motivational message based on performance
    fn generate_motivation_message(&self, performance_trend: f32) -> String {
        if performance_trend > 0.05 {
            "Great progress! You're improving with each attempt.".to_string()
        } else if performance_trend < -0.05 {
            "Stay focused! Small improvements add up over time.".to_string()
        } else {
            "You're maintaining consistent performance. Keep it up!".to_string()
        }
    }
}

/// Attention span configuration for modeling user focus
#[derive(Debug, Clone)]
pub struct AttentionSpanConfig {
    /// Base attention span in minutes
    pub base_attention_span: u32,
    /// Decline rate after peak attention
    pub decline_rate: f32,
    /// Break effectiveness for attention restoration
    pub break_effectiveness: f32,
}

impl Default for AttentionSpanConfig {
    fn default() -> Self {
        Self {
            base_attention_span: 45,  // 45 minutes base attention span
            decline_rate: 0.1,        // 10% decline per 15 minutes after peak
            break_effectiveness: 0.8, // 80% attention restoration after break
        }
    }
}

/// Break timing algorithm for optimal break suggestions
#[derive(Debug, Clone)]
pub struct BreakTimingAlgorithm {
    /// Minimum time between break suggestions
    pub min_break_interval: Duration,
    /// Performance threshold for break suggestion
    pub performance_threshold: f32,
    /// Time-based break interval
    pub time_based_interval: Duration,
}

impl Default for BreakTimingAlgorithm {
    fn default() -> Self {
        Self {
            min_break_interval: Duration::from_secs(900), // 15 minutes
            performance_threshold: 0.75, // Suggest break if performance drops below 75%
            time_based_interval: Duration::from_secs(2700), // 45 minutes
        }
    }
}

/// Session flow recommendation
#[derive(Debug, Clone)]
pub enum SessionFlowRecommendation {
    /// Continue with current session
    Continue {
        /// Estimated remaining effective time
        estimated_remaining_time: Duration,
        /// Motivational message
        motivation_message: String,
    },
    /// Take a break
    TakeBreak {
        /// Reason for break recommendation
        reason: String,
        /// Suggested break duration
        suggested_break_duration: Duration,
        /// Suggestion for break activity
        resume_suggestion: String,
    },
    /// Adjust exercise difficulty
    AdjustDifficulty {
        /// Reason for adjustment
        reason: String,
        /// Suggested difficulty change (-1.0 to 1.0)
        suggested_difficulty_change: f32,
        /// Alternative exercise types to try
        alternative_exercise_types: Vec<ExerciseType>,
    },
    /// Increase challenge level
    IncreaseChallenge {
        /// Reason for increase
        reason: String,
        /// Suggested difficulty increase
        suggested_difficulty_change: f32,
        /// New exercise types to introduce
        new_exercise_types: Vec<ExerciseType>,
    },
    /// End session
    EndSession {
        /// Reason for ending
        reason: String,
        /// Session summary
        session_summary: String,
    },
}

/// Individual exercise attempt
#[derive(Debug, Clone)]
pub struct ExerciseAttempt {
    /// Attempt number
    pub attempt_number: usize,
    /// Audio produced
    pub audio: AudioBuffer,
    /// When attempt was made
    pub timestamp: DateTime<Utc>,
    /// Quality score achieved
    pub quality_score: f32,
    /// Pronunciation score achieved
    pub pronunciation_score: f32,
    /// Time taken for evaluation
    pub evaluation_time: Duration,
    /// Feedback for this attempt
    pub feedback: AttemptFeedback,
}

/// Feedback for an individual attempt
#[derive(Debug, Clone)]
pub struct AttemptFeedback {
    /// Overall score for the attempt
    pub overall_score: f32,
    /// Quality component score
    pub quality_score: f32,
    /// Pronunciation component score
    pub pronunciation_score: f32,
    /// Things done well
    pub strengths: Vec<String>,
    /// Areas needing improvement
    pub weaknesses: Vec<String>,
    /// Specific suggestions
    pub suggestions: Vec<String>,
    /// Encouraging message
    pub encouragement: String,
}

/// Result of an exercise attempt
#[derive(Debug, Clone)]
pub struct AttemptResult {
    /// The attempt that was evaluated
    pub attempt: ExerciseAttempt,
    /// Whether this attempt met success criteria
    pub success: bool,
    /// Detailed criteria compliance
    pub meets_criteria: CriteriaCompliance,
    /// Recommended next steps
    pub next_steps: Vec<String>,
    /// Specific improvement suggestions
    pub improvement_suggestions: Vec<ImprovementSuggestion>,
}

/// Criteria compliance analysis
#[derive(Debug, Clone)]
pub struct CriteriaCompliance {
    /// Whether quality criteria was met
    pub quality_met: bool,
    /// Whether pronunciation criteria was met
    pub pronunciation_met: bool,
    /// Gap in quality score (if not met)
    pub quality_gap: f32,
    /// Gap in pronunciation score (if not met)
    pub pronunciation_gap: f32,
}

/// Specific improvement suggestion
#[derive(Debug, Clone)]
pub struct ImprovementSuggestion {
    /// Area needing improvement
    pub area: String,
    /// Current score in this area
    pub current_score: f32,
    /// Target score to achieve
    pub target_score: f32,
    /// Specific actions to take
    pub specific_actions: Vec<String>,
    /// Estimated practice time needed
    pub estimated_practice_time: Duration,
}

/// Complete exercise result
#[derive(Debug, Clone)]
pub struct ExerciseResult {
    /// Exercise that was completed
    pub exercise: TrainingExercise,
    /// All attempts made
    pub attempts: Vec<ExerciseAttempt>,
    /// Whether exercise was completed successfully
    pub success: bool,
    /// Time taken to complete
    pub completion_time: Duration,
    /// Final scores achieved
    pub final_scores: ExerciseScores,
}

/// Scores for an exercise
#[derive(Debug, Clone)]
pub struct ExerciseScores {
    /// Final quality score
    pub quality: f32,
    /// Final pronunciation score
    pub pronunciation: f32,
    /// Consistency across attempts
    pub consistency: f32,
    /// Improvement shown during exercise
    pub improvement: f32,
}

/// Session statistics
#[derive(Debug, Clone, Default)]
pub struct SessionStatistics {
    /// Total attempts across all exercises
    pub total_attempts: usize,
    /// Successful attempts
    pub successful_attempts: usize,
    /// Total time spent on evaluation
    pub total_evaluation_time: Duration,
    /// Number of exercises started
    pub exercises_started: usize,
    /// Number of exercises completed
    pub exercises_completed: usize,
}

/// Training session result
#[derive(Debug, Clone)]
pub struct TrainingSessionResult {
    /// The completed session
    pub session: TrainingSession,
    /// When session was completed
    pub completion_time: DateTime<Utc>,
    /// Total session duration
    pub session_duration: Duration,
    /// Number of exercises attempted
    pub total_exercises: usize,
    /// Number of exercises completed successfully
    pub successful_exercises: usize,
    /// Success rate
    pub success_rate: f32,
    /// Average scores across all exercises
    pub average_scores: SessionScores,
    /// Achievements earned in this session
    pub achievements: Vec<String>,
    /// Recommendations for future sessions
    pub recommendations: Vec<String>,
    /// Suggested next learning path
    pub next_learning_path: LearningPath,
}

/// Session-level scores
#[derive(Debug, Clone)]
pub struct SessionScores {
    /// Average quality score
    pub average_quality: f32,
    /// Average pronunciation score
    pub average_pronunciation: f32,
    /// Average fluency score
    pub average_fluency: f32,
    /// Overall session score
    pub overall_score: f32,
    /// Improvement trend throughout session
    pub improvement_trend: f32,
}

/// Suggested learning path
#[derive(Debug, Clone)]
pub struct LearningPath {
    /// Recommended focus areas
    pub suggested_focus_areas: Vec<FocusArea>,
    /// Recommended difficulty level
    pub difficulty_level: f32,
    /// Estimated time for next session
    pub estimated_duration: Duration,
    /// Recommended exercise types
    pub exercise_types: Vec<ExerciseType>,
}

/// Training configuration
#[derive(Debug, Clone)]
pub struct TrainingConfig {
    /// Maximum recommended exercises to return
    pub max_recommended_exercises: usize,
    /// Enable adaptive difficulty progression
    pub adaptive_difficulty: bool,
    /// Default exercise timeout
    pub default_timeout: Duration,
    /// Enable detailed feedback
    pub detailed_feedback: bool,
}

impl Default for TrainingConfig {
    fn default() -> Self {
        Self {
            max_recommended_exercises: 10,
            adaptive_difficulty: true,
            default_timeout: Duration::from_secs(300),
            detailed_feedback: true,
        }
    }
}

/// Training system metrics
#[derive(Debug, Default)]
struct TrainingMetrics {
    /// Total sessions created
    total_sessions: usize,
    /// Currently active sessions
    active_sessions: usize,
    /// Completed sessions
    completed_sessions: usize,
    /// Total attempts across all sessions
    total_attempts: usize,
    /// Successful attempts
    successful_attempts: usize,
    /// Total time spent in sessions
    total_session_time: Duration,
    /// Total evaluation time
    total_evaluation_time: Duration,
}

/// Training system statistics
#[derive(Debug, Clone)]
pub struct TrainingSystemStats {
    /// Total sessions created
    pub total_sessions: usize,
    /// Currently active sessions
    pub active_sessions: usize,
    /// Successfully completed sessions
    pub completed_sessions: usize,
    /// Total exercises available
    pub total_exercises: usize,
    /// Total attempts made
    pub total_attempts: usize,
    /// Successful attempts
    pub successful_attempts: usize,
    /// Overall success rate
    pub success_rate: f32,
    /// Average session duration
    pub average_session_duration: Duration,
    /// Average evaluation time per attempt
    pub average_evaluation_time: Duration,
}

/// Collaborative learning features for peer interaction and group exercises
#[derive(Clone)]
pub struct CollaborativeLearningSystem {
    /// Peer practice sessions
    peer_sessions: Arc<RwLock<HashMap<String, PeerPracticeSession>>>,
    /// Group exercise completion tracking
    group_exercises: Arc<RwLock<HashMap<String, GroupExerciseSession>>>,
    /// Cooperative challenges
    cooperative_challenges: Arc<RwLock<HashMap<String, CooperativeChallenge>>>,
    /// Peer feedback system
    peer_feedback: Arc<RwLock<PeerFeedbackSystem>>,
    /// Virtual study groups
    virtual_study_groups: Arc<RwLock<HashMap<String, VirtualStudyGroup>>>,
    /// Configuration
    config: CollaborativeLearningConfig,
}

impl CollaborativeLearningSystem {
    /// Create new collaborative learning system
    pub async fn new() -> Result<Self, FeedbackError> {
        Ok(Self {
            peer_sessions: Arc::new(RwLock::new(HashMap::new())),
            group_exercises: Arc::new(RwLock::new(HashMap::new())),
            cooperative_challenges: Arc::new(RwLock::new(HashMap::new())),
            peer_feedback: Arc::new(RwLock::new(PeerFeedbackSystem::new())),
            virtual_study_groups: Arc::new(RwLock::new(HashMap::new())),
            config: CollaborativeLearningConfig::default(),
        })
    }

    /// Create peer practice session
    pub async fn create_peer_session(
        &self,
        initiator_id: &str,
        target_peer_id: &str,
        exercise_id: &str,
    ) -> Result<PeerPracticeSession, FeedbackError> {
        let session = PeerPracticeSession {
            session_id: Uuid::new_v4().to_string(),
            initiator_id: initiator_id.to_string(),
            peer_id: target_peer_id.to_string(),
            exercise_id: exercise_id.to_string(),
            status: PeerSessionStatus::Pending,
            created_at: Utc::now(),
            started_at: None,
            completed_at: None,
            initiator_results: None,
            peer_results: None,
            mutual_feedback: Vec::new(),
        };

        self.peer_sessions
            .write()
            .unwrap()
            .insert(session.session_id.clone(), session.clone());
        Ok(session)
    }

    /// Start group exercise session
    pub async fn start_group_exercise(
        &self,
        group_id: &str,
        exercise_id: &str,
        participants: Vec<String>,
    ) -> Result<GroupExerciseSession, FeedbackError> {
        let session = GroupExerciseSession {
            session_id: Uuid::new_v4().to_string(),
            group_id: group_id.to_string(),
            exercise_id: exercise_id.to_string(),
            participants,
            status: GroupExerciseStatus::Active,
            created_at: Utc::now(),
            completed_at: None,
            participant_results: HashMap::new(),
            group_score: 0.0,
            completion_rate: 0.0,
        };

        self.group_exercises
            .write()
            .unwrap()
            .insert(session.session_id.clone(), session.clone());
        Ok(session)
    }

    /// Create cooperative challenge
    pub async fn create_cooperative_challenge(
        &self,
        challenge_name: &str,
        participants: Vec<String>,
        target_score: f32,
    ) -> Result<CooperativeChallenge, FeedbackError> {
        let challenge = CooperativeChallenge {
            challenge_id: Uuid::new_v4().to_string(),
            name: challenge_name.to_string(),
            participants,
            target_score,
            current_score: 0.0,
            status: CooperativeChallengeStatus::Active,
            created_at: Utc::now(),
            deadline: Utc::now() + chrono::Duration::days(7),
            participant_contributions: HashMap::new(),
            milestones: Vec::new(),
        };

        self.cooperative_challenges
            .write()
            .unwrap()
            .insert(challenge.challenge_id.clone(), challenge.clone());
        Ok(challenge)
    }

    /// Submit peer feedback
    pub async fn submit_peer_feedback(
        &self,
        session_id: &str,
        feedback: PeerFeedback,
    ) -> Result<(), FeedbackError> {
        let mut peer_feedback_system = self.peer_feedback.write().unwrap();
        peer_feedback_system.add_feedback(session_id, feedback);
        Ok(())
    }

    /// Create virtual study group
    pub async fn create_virtual_study_group(
        &self,
        group_name: &str,
        creator_id: &str,
        focus_areas: Vec<FocusArea>,
    ) -> Result<VirtualStudyGroup, FeedbackError> {
        let group = VirtualStudyGroup {
            group_id: Uuid::new_v4().to_string(),
            name: group_name.to_string(),
            creator_id: creator_id.to_string(),
            members: vec![creator_id.to_string()],
            focus_areas,
            status: StudyGroupStatus::Active,
            created_at: Utc::now(),
            last_activity: Utc::now(),
            group_progress: GroupProgress::default(),
            study_sessions: Vec::new(),
        };

        self.virtual_study_groups
            .write()
            .unwrap()
            .insert(group.group_id.clone(), group.clone());
        Ok(group)
    }
}

/// Peer practice session
#[derive(Debug, Clone)]
pub struct PeerPracticeSession {
    /// Session identifier
    pub session_id: String,
    /// ID of the user who initiated the session
    pub initiator_id: String,
    /// ID of the peer participant
    pub peer_id: String,
    /// Exercise being practiced
    pub exercise_id: String,
    /// Current status of the session
    pub status: PeerSessionStatus,
    /// When the session was created
    pub created_at: DateTime<Utc>,
    /// When the session was started
    pub started_at: Option<DateTime<Utc>>,
    /// When the session was completed
    pub completed_at: Option<DateTime<Utc>>,
    /// Results from the initiator
    pub initiator_results: Option<TrainingScores>,
    /// Results from the peer
    pub peer_results: Option<TrainingScores>,
    /// Feedback exchanged between participants
    pub mutual_feedback: Vec<PeerFeedback>,
}

/// Group exercise session
#[derive(Debug, Clone)]
pub struct GroupExerciseSession {
    /// Session identifier
    pub session_id: String,
    /// Group identifier
    pub group_id: String,
    /// Exercise being practiced
    pub exercise_id: String,
    /// List of participant user IDs
    pub participants: Vec<String>,
    /// Current status of the session
    pub status: GroupExerciseStatus,
    /// When the session was created
    pub created_at: DateTime<Utc>,
    /// When the session was completed
    pub completed_at: Option<DateTime<Utc>>,
    /// Results from each participant
    pub participant_results: HashMap<String, TrainingScores>,
    /// Overall group score
    pub group_score: f32,
    /// Percentage of participants who completed
    pub completion_rate: f32,
}

/// Cooperative challenge
#[derive(Debug, Clone)]
pub struct CooperativeChallenge {
    /// Challenge identifier
    pub challenge_id: String,
    /// Challenge name
    pub name: String,
    /// List of participant user IDs
    pub participants: Vec<String>,
    /// Target score to achieve
    pub target_score: f32,
    /// Current cumulative score
    pub current_score: f32,
    /// Current status of the challenge
    pub status: CooperativeChallengeStatus,
    /// When the challenge was created
    pub created_at: DateTime<Utc>,
    /// Challenge deadline
    pub deadline: DateTime<Utc>,
    /// Score contributions from each participant
    pub participant_contributions: HashMap<String, f32>,
    /// Challenge milestones
    pub milestones: Vec<ChallengeMilestone>,
}

/// Peer feedback system
#[derive(Debug, Clone)]
pub struct PeerFeedbackSystem {
    /// History of feedback for each session
    feedback_history: HashMap<String, Vec<PeerFeedback>>,
}

impl PeerFeedbackSystem {
    /// Create a new peer feedback system
    pub fn new() -> Self {
        Self {
            feedback_history: HashMap::new(),
        }
    }

    /// Add feedback to the system
    pub fn add_feedback(&mut self, session_id: &str, feedback: PeerFeedback) {
        self.feedback_history
            .entry(session_id.to_string())
            .or_insert_with(Vec::new)
            .push(feedback);
    }
}

/// Virtual study group
#[derive(Debug, Clone)]
pub struct VirtualStudyGroup {
    /// Group identifier
    pub group_id: String,
    /// Group name
    pub name: String,
    /// ID of the user who created the group
    pub creator_id: String,
    /// List of member user IDs
    pub members: Vec<String>,
    /// Focus areas for the group
    pub focus_areas: Vec<FocusArea>,
    /// Current status of the group
    pub status: StudyGroupStatus,
    /// When the group was created
    pub created_at: DateTime<Utc>,
    /// Last activity timestamp
    pub last_activity: DateTime<Utc>,
    /// Group progress tracking
    pub group_progress: GroupProgress,
    /// Study sessions for the group
    pub study_sessions: Vec<GroupStudySession>,
}

/// Peer feedback
#[derive(Debug, Clone)]
pub struct PeerFeedback {
    /// Feedback identifier
    pub feedback_id: String,
    /// User ID who provided the feedback
    pub from_user: String,
    /// User ID who received the feedback
    pub to_user: String,
    /// Session identifier
    pub session_id: String,
    /// Rating score (0.0 to 5.0)
    pub rating: f32,
    /// Text comments
    pub comments: String,
    /// Identified strengths
    pub strengths: Vec<String>,
    /// Improvement suggestions
    pub suggestions: Vec<String>,
    /// When the feedback was created
    pub created_at: DateTime<Utc>,
}

/// Challenge milestone
#[derive(Debug, Clone)]
pub struct ChallengeMilestone {
    /// Milestone identifier
    pub milestone_id: String,
    /// Milestone name
    pub name: String,
    /// Target score to achieve this milestone
    pub target_score: f32,
    /// Whether the milestone has been achieved
    pub achieved: bool,
    /// When the milestone was achieved
    pub achieved_at: Option<DateTime<Utc>>,
    /// Reward for achieving the milestone
    pub reward: String,
}

/// Group progress tracking
#[derive(Debug, Clone, Default)]
pub struct GroupProgress {
    /// Total number of sessions
    pub total_sessions: usize,
    /// Number of completed exercises
    pub completed_exercises: usize,
    /// Average score across all group members
    pub average_group_score: f32,
    /// Rate of improvement over time
    pub improvement_rate: f32,
    /// Score for collaboration effectiveness
    pub collaboration_score: f32,
}

/// Group study session
#[derive(Debug, Clone)]
pub struct GroupStudySession {
    /// Session identifier
    pub session_id: String,
    /// Session topic
    pub topic: String,
    /// Scheduled start time
    pub scheduled_time: DateTime<Utc>,
    /// Session duration
    pub duration: Duration,
    /// List of attendee user IDs
    pub attendees: Vec<String>,
    /// Current status of the session
    pub status: StudySessionStatus,
}

/// Peer session status
#[derive(Debug, Clone, PartialEq)]
pub enum PeerSessionStatus {
    /// Session is pending acceptance
    Pending,
    /// Session is active and in progress
    Active,
    /// Session has been completed
    Completed,
    /// Session has been cancelled
    Cancelled,
}

/// Group exercise status
#[derive(Debug, Clone, PartialEq)]
pub enum GroupExerciseStatus {
    /// Exercise is active and in progress
    Active,
    /// Exercise has been completed
    Completed,
    /// Exercise has been cancelled
    Cancelled,
}

/// Cooperative challenge status
#[derive(Debug, Clone, PartialEq)]
pub enum CooperativeChallengeStatus {
    /// Challenge is active and in progress
    Active,
    /// Challenge has been completed successfully
    Completed,
    /// Challenge has failed to meet targets
    Failed,
    /// Challenge has been cancelled
    Cancelled,
}

/// Study group status
#[derive(Debug, Clone, PartialEq)]
pub enum StudyGroupStatus {
    /// Group is active and accepting new members
    Active,
    /// Group is inactive but not archived
    Inactive,
    /// Group has been archived
    Archived,
}

/// Study session status
#[derive(Debug, Clone, PartialEq)]
pub enum StudySessionStatus {
    /// Session is scheduled for the future
    Scheduled,
    /// Session is active and in progress
    Active,
    /// Session has been completed
    Completed,
    /// Session has been cancelled
    Cancelled,
}

/// Collaborative learning configuration
#[derive(Debug, Clone)]
pub struct CollaborativeLearningConfig {
    /// Maximum number of simultaneous peer sessions per user
    pub max_peer_sessions: usize,
    /// Maximum size for group exercises
    pub max_group_size: usize,
    /// Default duration for challenges in days
    pub challenge_duration_days: i64,
    /// Timeout for peer feedback in hours
    pub feedback_timeout_hours: i64,
    /// Maximum number of members in a study group
    pub study_group_max_members: usize,
}

impl Default for CollaborativeLearningConfig {
    fn default() -> Self {
        Self {
            max_peer_sessions: 10,
            max_group_size: 8,
            challenge_duration_days: 14,
            feedback_timeout_hours: 48,
            study_group_max_members: 20,
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[tokio::test]
    async fn test_trainer_creation() {
        let trainer = InteractiveTrainer::new().await.unwrap();
        let stats = trainer.get_statistics().await.unwrap();

        assert_eq!(stats.active_sessions, 0);
        assert_eq!(stats.total_sessions, 0);
        assert!(
            stats.total_exercises >= 500,
            "Exercise library should contain at least 500 exercises"
        );
    }

    #[tokio::test]
    async fn test_session_creation() {
        let trainer = InteractiveTrainer::new().await.unwrap();
        let session = trainer.start_session("test_user", None).await.unwrap();

        assert_eq!(session.user_id, "test_user");
        assert_eq!(session.status, TrainingSessionStatus::Active);
        assert!(session.current_exercise.is_none());
    }

    #[tokio::test]
    async fn test_exercise_recommendation() {
        let trainer = InteractiveTrainer::new().await.unwrap();
        let exercises = trainer
            .get_recommended_exercises("test_user", 0.5, &[FocusArea::Pronunciation])
            .await
            .unwrap();

        assert!(!exercises.is_empty());
        for exercise in &exercises {
            assert!(exercise.focus_areas.contains(&FocusArea::Pronunciation));
            assert!((exercise.difficulty - 0.5).abs() <= 0.3);
        }
    }

    #[tokio::test]
    async fn test_exercise_session() {
        let trainer = InteractiveTrainer::new().await.unwrap();
        let session = trainer.start_session("test_user", None).await.unwrap();

        // Use the first exercise ID from the new comprehensive library
        let exercise_session = trainer
            .start_exercise(&session.session_id, "phoneme_vowel_a_1")
            .await
            .unwrap();

        assert_eq!(exercise_session.exercise.exercise_id, "phoneme_vowel_a_1");
        assert_eq!(exercise_session.status, ExerciseSessionStatus::InProgress);
        assert_eq!(exercise_session.attempts.len(), 0);
    }

    #[tokio::test]
    async fn test_attempt_submission() {
        let trainer = InteractiveTrainer::new().await.unwrap();
        let session = trainer.start_session("test_user", None).await.unwrap();
        let _ = trainer
            .start_exercise(&session.session_id, "phoneme_vowel_a_1")
            .await
            .unwrap();

        let audio = AudioBuffer::new(vec![0.1; 16000], 16000, 1);
        let result = trainer
            .submit_attempt(&session.session_id, &audio)
            .await
            .unwrap();

        assert!(result.attempt.quality_score >= 0.0);
        assert!(result.attempt.quality_score <= 1.0);
        assert!(result.attempt.pronunciation_score >= 0.0);
        assert!(result.attempt.pronunciation_score <= 1.0);
        assert!(!result.next_steps.is_empty());
    }

    #[tokio::test]
    async fn test_session_completion() {
        let trainer = InteractiveTrainer::new().await.unwrap();
        let session = trainer.start_session("test_user", None).await.unwrap();

        let result = trainer.complete_session(&session.session_id).await.unwrap();

        assert_eq!(result.session.status, TrainingSessionStatus::Completed);
        assert!(result.session_duration >= Duration::from_secs(0));
        assert_eq!(result.total_exercises, 0); // No exercises completed
        assert!(!result.recommendations.is_empty());
    }

    #[tokio::test]
    async fn test_custom_exercise_creation() {
        let trainer = InteractiveTrainer::new().await.unwrap();

        let specification = ExerciseSpecification {
            focus_areas: vec![FocusArea::Pronunciation],
            difficulty: 0.6,
            exercise_type: ExerciseType::Pronunciation,
            custom_text: Some("Custom practice sentence".to_string()),
            duration_constraint: Some(Duration::from_secs(180)),
        };

        let exercise = trainer
            .create_custom_exercise(&specification)
            .await
            .unwrap();

        assert_eq!(exercise.difficulty, 0.6);
        assert_eq!(exercise.target_text, "Custom practice sentence");
        assert_eq!(exercise.exercise_type, ExerciseType::Pronunciation);
        assert!(exercise.focus_areas.contains(&FocusArea::Pronunciation));
    }

    #[tokio::test]
    async fn test_exercise_evaluation() {
        let trainer = InteractiveTrainer::new().await.unwrap();
        let library = trainer.exercise_library.read().unwrap();
        let exercise = library.exercises.first().unwrap();

        let audio = AudioBuffer::new(vec![0.1; 16000], 16000, 1);
        let result = trainer.evaluate_exercise(exercise, &audio).await.unwrap();

        assert_eq!(result.exercise.exercise_id, exercise.exercise_id);
        assert!(result.final_scores.quality >= 0.0);
        assert!(result.final_scores.pronunciation >= 0.0);
        assert!(!result.feedback.feedback_items.is_empty());
    }

    #[tokio::test]
    async fn test_comprehensive_exercise_library() {
        let trainer = InteractiveTrainer::new().await.unwrap();
        let library = trainer.exercise_library.read().unwrap();
        let total_exercises = library.exercises.len();

        // Verify we have 500+ exercises
        assert!(
            total_exercises >= 500,
            "Expected at least 500 exercises, found {}",
            total_exercises
        );

        // Count by difficulty level
        let beginner = library
            .exercises
            .iter()
            .filter(|e| e.difficulty <= 0.3)
            .count();
        let intermediate = library
            .exercises
            .iter()
            .filter(|e| e.difficulty > 0.3 && e.difficulty <= 0.6)
            .count();
        let advanced = library
            .exercises
            .iter()
            .filter(|e| e.difficulty > 0.6)
            .count();

        // Verify proper distribution
        assert!(beginner > 0, "Should have beginner exercises");
        assert!(intermediate > 0, "Should have intermediate exercises");
        assert!(advanced > 0, "Should have advanced exercises");

        // Verify all exercises have proper structure
        for exercise in &library.exercises {
            assert!(
                !exercise.exercise_id.is_empty(),
                "Exercise ID should not be empty"
            );
            assert!(
                !exercise.name.is_empty(),
                "Exercise name should not be empty"
            );
            assert!(
                !exercise.target_text.is_empty(),
                "Target text should not be empty"
            );
            assert!(
                exercise.difficulty >= 0.0 && exercise.difficulty <= 1.0,
                "Difficulty should be between 0.0 and 1.0"
            );
            assert!(
                !exercise.focus_areas.is_empty(),
                "Should have at least one focus area"
            );
        }

        println!(" Comprehensive exercise library verified:");
        println!("  - Total exercises: {}", total_exercises);
        println!("  - Beginner (0.1-0.3): {}", beginner);
        println!("  - Intermediate (0.4-0.6): {}", intermediate);
        println!("  - Advanced (0.7-1.0): {}", advanced);
    }
}
