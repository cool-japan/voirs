/* tslint:disable */
/* eslint-disable */

/* auto-generated by NAPI-RS */

/**
 * Configuration options for creating a VoiRS pipeline
 */
export interface PipelineOptions {
  /** Whether to use GPU acceleration */
  useGpu?: boolean
  /** Number of worker threads */
  numThreads?: number
  /** Cache directory path */
  cacheDir?: string
  /** Device type (cpu, cuda, metal, vulkan) */
  device?: string
}

/**
 * Synthesis configuration options
 */
export interface SynthesisOptions {
  /** Speaking rate multiplier (0.5-2.0) */
  speakingRate?: number
  /** Pitch shift in semitones (-12.0 to 12.0) */
  pitchShift?: number
  /** Volume gain in dB (-20.0 to 20.0) */
  volumeGain?: number
  /** Enable audio enhancement */
  enableEnhancement?: boolean
  /** Output audio format */
  outputFormat?: 'wav' | 'flac' | 'mp3' | 'opus' | 'ogg'
  /** Sample rate in Hz */
  sampleRate?: number
  /** Quality level */
  quality?: 'low' | 'medium' | 'high' | 'ultra'
}

/**
 * Audio buffer result
 */
export interface AudioBufferResult {
  /** Raw audio samples as Buffer */
  samples: Buffer
  /** Sample rate in Hz */
  sampleRate: number
  /** Number of channels */
  channels: number
  /** Duration in seconds */
  duration: number
}

/**
 * Synthesis metrics for performance monitoring
 */
export interface SynthesisMetrics {
  /** Processing time in milliseconds */
  processingTimeMs: number
  /** Audio duration in milliseconds */
  audioDurationMs: number
  /** Real-time factor (processing time / audio duration) */
  realTimeFactor: number
  /** Memory usage in MB */
  memoryUsageMb: number
  /** Cache hit rate (0.0 to 1.0) */
  cacheHitRate: number
}

/**
 * Enhanced synthesis result with metrics
 */
export interface SynthesisResult {
  /** Audio buffer result */
  audio: AudioBufferResult
  /** Performance metrics */
  metrics: SynthesisMetrics
}

/**
 * Structured error information
 */
export interface ErrorInfo {
  /** Error code */
  code: string
  /** Error message */
  message: string
  /** Additional details */
  details?: string
  /** Suggested solution */
  suggestion?: string
}

/**
 * Audio analysis result
 */
export interface AudioAnalysis {
  /** Duration in seconds */
  durationSeconds: number
  /** Sample rate in Hz */
  sampleRate: number
  /** Number of channels */
  channels: number
  /** RMS energy level */
  rmsEnergy: number
  /** Zero crossing rate */
  zeroCrossingRate: number
  /** Spectral centroid */
  spectralCentroid: number
  /** Silence regions [start, end] in samples */
  silenceRegions: number[][]
}

/**
 * Performance information
 */
export interface PerformanceInfo {
  /** Number of CPU cores */
  cpuCores: number
  /** Memory usage in MB */
  memoryUsageMb: number
  /** Whether GPU is available */
  gpuAvailable: boolean
  /** Cache size in MB */
  cacheSizeMb: number
  /** Number of threads */
  threadCount: number
}

/**
 * Voice information
 */
export interface VoiceInfo {
  /** Unique voice identifier */
  id: string
  /** Human-readable voice name */
  name: string
  /** Language code (e.g., 'en-US', 'ja-JP') */
  language: string
  /** Quality level */
  quality: string
  /** Whether the voice is currently available */
  isAvailable: boolean
}

/**
 * Progress callback function type
 */
export type ProgressCallback = (progress: number) => void

/**
 * Error callback function type
 */
export type ErrorCallback = (error: string) => void

/**
 * Audio chunk callback function type
 */
export type ChunkCallback = (chunk: Buffer) => void

/**
 * VoiRS Pipeline - Main interface for speech synthesis
 */
export class VoirsPipeline {
  /**
   * Create a new VoiRS pipeline
   * @param options Configuration options
   */
  constructor(options?: PipelineOptions)

  /**
   * Synthesize text to audio synchronously
   * @param text Text to synthesize
   * @param options Synthesis options
   * @returns Audio buffer result
   */
  synthesizeSync(text: string, options?: SynthesisOptions): AudioBufferResult

  /**
   * Synthesize text to audio asynchronously
   * @param text Text to synthesize
   * @param options Synthesis options
   * @returns Promise resolving to audio buffer result
   */
  synthesize(text: string, options?: SynthesisOptions): Promise<AudioBufferResult>

  /**
   * Synthesize SSML to audio asynchronously
   * @param ssml SSML content to synthesize
   * @returns Promise resolving to audio buffer result
   */
  synthesizeSsml(ssml: string): Promise<AudioBufferResult>

  /**
   * Synthesize with callbacks for progress updates
   * @param text Text to synthesize
   * @param options Synthesis options
   * @param progressCallback Called with progress updates (0.0 to 1.0)
   * @param errorCallback Called if an error occurs
   * @returns Promise resolving to audio buffer result
   */
  synthesizeWithCallbacks(
    text: string,
    options?: SynthesisOptions,
    progressCallback?: ProgressCallback,
    errorCallback?: ErrorCallback
  ): Promise<AudioBufferResult>

  /**
   * Set the voice for synthesis
   * @param voiceId Voice identifier
   */
  setVoice(voiceId: string): Promise<void>

  /**
   * Get the current voice
   * @returns Promise resolving to current voice ID or null
   */
  getVoice(): Promise<string | null>

  /**
   * List available voices
   * @returns Promise resolving to array of voice information
   */
  listVoices(): Promise<VoiceInfo[]>

  /**
   * Enhanced synthesis with metrics
   * @param text Text to synthesize
   * @param options Synthesis options
   * @returns Promise resolving to synthesis result with metrics
   */
  synthesizeWithMetrics(text: string, options?: SynthesisOptions): Promise<SynthesisResult>

  /**
   * Enhanced SSML synthesis with metrics
   * @param ssml SSML content to synthesize
   * @returns Promise resolving to synthesis result with metrics
   */
  synthesizeSsmlWithMetrics(ssml: string): Promise<SynthesisResult>

  /**
   * Batch synthesis with progress tracking
   * @param texts Array of texts to synthesize
   * @param options Synthesis options
   * @param progressCallback Called with progress updates (current, total, progress)
   * @returns Promise resolving to array of synthesis results
   */
  batchSynthesize(
    texts: string[],
    options?: SynthesisOptions,
    progressCallback?: (current: number, total: number, progress: number) => void
  ): Promise<SynthesisResult[]>

  /**
   * Analyze audio buffer
   * @param audioBuffer Audio buffer to analyze
   * @returns Promise resolving to audio analysis result
   */
  analyzeAudio(audioBuffer: AudioBufferResult): Promise<AudioAnalysis>

  /**
   * Get performance information
   * @returns Promise resolving to performance information
   */
  getPerformanceInfo(): Promise<PerformanceInfo>

  /**
   * Get pipeline information
   * @returns Pipeline and runtime information
   */
  getInfo(): any
}

/**
 * Streaming synthesis with real-time callbacks
 * @param pipeline VoiRS pipeline instance
 * @param text Text to synthesize
 * @param chunkCallback Called for each audio chunk
 * @param progressCallback Called with progress updates
 * @param options Synthesis options
 */
export function synthesizeStreaming(
  pipeline: VoirsPipeline,
  text: string,
  chunkCallback: ChunkCallback,
  progressCallback?: ProgressCallback,
  options?: SynthesisOptions
): Promise<void>

/**
 * Utility functions
 */
export namespace utils {
  /**
   * Convert audio buffer to WAV format
   * @param audioBuffer Audio buffer result
   * @returns WAV file buffer
   */
  export function toWav(audioBuffer: AudioBufferResult): Buffer

  /**
   * Get supported audio formats
   * @returns Array of supported format strings
   */
  export function getSupportedFormats(): string[]

  /**
   * Get supported quality levels
   * @returns Array of supported quality strings
   */
  export function getSupportedQualities(): string[]

  /**
   * Validate synthesis options
   * @param options Options to validate
   * @returns True if valid, throws error if invalid
   */
  export function validateSynthesisOptions(options: SynthesisOptions): boolean

  /**
   * Resample audio buffer to target sample rate
   * @param audioBuffer Audio buffer to resample
   * @param targetSampleRate Target sample rate in Hz
   * @returns Resampled audio buffer
   */
  export function resampleAudio(
    audioBuffer: AudioBufferResult,
    targetSampleRate: number
  ): Promise<AudioBufferResult>

  /**
   * Mix two audio buffers
   * @param audio1 First audio buffer
   * @param audio2 Second audio buffer
   * @param mixRatio Mix ratio (0.0 to 1.0)
   * @returns Mixed audio buffer
   */
  export function mixAudio(
    audio1: AudioBufferResult,
    audio2: AudioBufferResult,
    mixRatio?: number
  ): Promise<AudioBufferResult>
}

/**
 * Recognition result
 */
export interface RecognitionResult {
  /** Recognized text */
  text: string
  /** Confidence score (0.0 to 1.0) */
  confidence: number
  /** Detected language */
  language: string
  /** Processing time in milliseconds */
  processingTimeMs: number
}

/**
 * Audio analysis result for recognition
 */
export interface AudioAnalysisResult {
  /** Duration in seconds */
  durationSeconds: number
  /** Sample rate in Hz */
  sampleRate: number
  /** Number of channels */
  channels: number
  /** RMS energy level */
  rmsEnergy: number
  /** Zero crossing rate */
  zeroCrossingRate: number
  /** Spectral centroid */
  spectralCentroid: number
}

/**
 * ASR Model for speech recognition
 */
export class ASRModel {
  /**
   * Create a new ASR model with Whisper
   * @param modelSize Model size (tiny, base, small, medium, large)
   * @returns ASR model instance
   */
  static whisper(modelSize?: string): ASRModel

  /**
   * Recognize speech from audio buffer
   * @param audio Audio buffer to recognize
   * @returns Promise resolving to recognition result
   */
  recognize(audio: AudioBufferResult): Promise<RecognitionResult>

  /**
   * Get supported languages
   * @returns Array of supported language codes
   */
  supportedLanguages(): string[]
}

/**
 * Audio analyzer for advanced analysis
 */
export class AudioAnalyzer {
  /**
   * Create a new audio analyzer
   */
  constructor()

  /**
   * Analyze audio buffer
   * @param audio Audio buffer to analyze
   * @returns Promise resolving to analysis result
   */
  analyze(audio: AudioBufferResult): Promise<AudioAnalysisResult>
}

/**
 * Error types
 */
export class VoirsError extends Error {
  constructor(message: string, code?: string)
  readonly code?: string
}

export class SynthesisError extends VoirsError {
  constructor(message: string, cause?: Error)
  readonly cause?: Error
}

export class VoiceError extends VoirsError {
  constructor(message: string, voiceId?: string)
  readonly voiceId?: string
}

export class ConfigurationError extends VoirsError {
  constructor(message: string, key?: string)
  readonly key?: string
}