/* tslint:disable */
/* eslint-disable */

/* auto-generated by NAPI-RS */

/**
 * Configuration options for creating a VoiRS pipeline
 */
export interface PipelineOptions {
  /** Whether to use GPU acceleration */
  useGpu?: boolean
  /** Number of worker threads */
  numThreads?: number
  /** Cache directory path */
  cacheDir?: string
  /** Device type (cpu, cuda, metal, vulkan) */
  device?: string
}

/**
 * Synthesis configuration options
 */
export interface SynthesisOptions {
  /** Speaking rate multiplier (0.5-2.0) */
  speakingRate?: number
  /** Pitch shift in semitones (-12.0 to 12.0) */
  pitchShift?: number
  /** Volume gain in dB (-20.0 to 20.0) */
  volumeGain?: number
  /** Enable audio enhancement */
  enableEnhancement?: boolean
  /** Output audio format */
  outputFormat?: 'wav' | 'flac' | 'mp3' | 'opus' | 'ogg'
  /** Sample rate in Hz */
  sampleRate?: number
  /** Quality level */
  quality?: 'low' | 'medium' | 'high' | 'ultra'
}

/**
 * Audio buffer result
 */
export interface AudioBufferResult {
  /** Raw audio samples as Buffer */
  samples: Buffer
  /** Sample rate in Hz */
  sampleRate: number
  /** Number of channels */
  channels: number
  /** Duration in seconds */
  duration: number
}

/**
 * Voice information
 */
export interface VoiceInfo {
  /** Unique voice identifier */
  id: string
  /** Human-readable voice name */
  name: string
  /** Language code (e.g., 'en-US', 'ja-JP') */
  language: string
  /** Quality level */
  quality: string
  /** Whether the voice is currently available */
  isAvailable: boolean
}

/**
 * Progress callback function type
 */
export type ProgressCallback = (progress: number) => void

/**
 * Error callback function type
 */
export type ErrorCallback = (error: string) => void

/**
 * Audio chunk callback function type
 */
export type ChunkCallback = (chunk: Buffer) => void

/**
 * VoiRS Pipeline - Main interface for speech synthesis
 */
export class VoirsPipeline {
  /**
   * Create a new VoiRS pipeline
   * @param options Configuration options
   */
  constructor(options?: PipelineOptions)

  /**
   * Synthesize text to audio synchronously
   * @param text Text to synthesize
   * @param options Synthesis options
   * @returns Audio buffer result
   */
  synthesizeSync(text: string, options?: SynthesisOptions): AudioBufferResult

  /**
   * Synthesize text to audio asynchronously
   * @param text Text to synthesize
   * @param options Synthesis options
   * @returns Promise resolving to audio buffer result
   */
  synthesize(text: string, options?: SynthesisOptions): Promise<AudioBufferResult>

  /**
   * Synthesize SSML to audio asynchronously
   * @param ssml SSML content to synthesize
   * @returns Promise resolving to audio buffer result
   */
  synthesizeSsml(ssml: string): Promise<AudioBufferResult>

  /**
   * Synthesize with callbacks for progress updates
   * @param text Text to synthesize
   * @param options Synthesis options
   * @param progressCallback Called with progress updates (0.0 to 1.0)
   * @param errorCallback Called if an error occurs
   * @returns Promise resolving to audio buffer result
   */
  synthesizeWithCallbacks(
    text: string,
    options?: SynthesisOptions,
    progressCallback?: ProgressCallback,
    errorCallback?: ErrorCallback
  ): Promise<AudioBufferResult>

  /**
   * Set the voice for synthesis
   * @param voiceId Voice identifier
   */
  setVoice(voiceId: string): Promise<void>

  /**
   * Get the current voice
   * @returns Promise resolving to current voice ID or null
   */
  getVoice(): Promise<string | null>

  /**
   * List available voices
   * @returns Promise resolving to array of voice information
   */
  listVoices(): Promise<VoiceInfo[]>

  /**
   * Get pipeline information
   * @returns Pipeline and runtime information
   */
  getInfo(): any
}

/**
 * Streaming synthesis with real-time callbacks
 * @param pipeline VoiRS pipeline instance
 * @param text Text to synthesize
 * @param chunkCallback Called for each audio chunk
 * @param progressCallback Called with progress updates
 * @param options Synthesis options
 */
export function synthesizeStreaming(
  pipeline: VoirsPipeline,
  text: string,
  chunkCallback: ChunkCallback,
  progressCallback?: ProgressCallback,
  options?: SynthesisOptions
): Promise<void>

/**
 * Utility functions
 */
export namespace utils {
  /**
   * Convert audio buffer to WAV format
   * @param audioBuffer Audio buffer result
   * @returns WAV file buffer
   */
  export function toWav(audioBuffer: AudioBufferResult): Buffer

  /**
   * Get supported audio formats
   * @returns Array of supported format strings
   */
  export function getSupportedFormats(): string[]

  /**
   * Get supported quality levels
   * @returns Array of supported quality strings
   */
  export function getSupportedQualities(): string[]

  /**
   * Validate synthesis options
   * @param options Options to validate
   * @returns True if valid, throws error if invalid
   */
  export function validateSynthesisOptions(options: SynthesisOptions): boolean
}

/**
 * Error types
 */
export class VoirsError extends Error {
  constructor(message: string, code?: string)
  readonly code?: string
}

export class SynthesisError extends VoirsError {
  constructor(message: string, cause?: Error)
  readonly cause?: Error
}

export class VoiceError extends VoirsError {
  constructor(message: string, voiceId?: string)
  readonly voiceId?: string
}

export class ConfigurationError extends VoirsError {
  constructor(message: string, key?: string)
  readonly key?: string
}